# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `pdf-reader` gem.
# Please instead update this file by running `bin/tapioca gem pdf-reader`.


# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `pdf-reader` gem.
# Please instead update this file by running `bundle exec spoom srb sigs export`.

# source://pdf-reader//lib/pdf/reader.rb#33
module PDF; end

# The Reader class serves as an entry point for parsing a PDF file.
#
# PDF is a page based file format. There is some data associated with the
# document (metadata, bookmarks, etc) but all visible content is stored
# under a Page object.
#
# In most use cases for extracting and examining the contents of a PDF it
# makes sense to traverse the information using page based iteration.
#
# In addition to the documentation here, check out the
# PDF::Reader::Page class.
#
# == File Metadata
#
#   reader = PDF::Reader.new("somefile.pdf")
#
#   puts reader.pdf_version
#   puts reader.info
#   puts reader.metadata
#   puts reader.page_count
#
# == Iterating over page content
#
#   reader = PDF::Reader.new("somefile.pdf")
#
#   reader.pages.each do |page|
#     puts page.fonts
#     puts page.images
#     puts page.text
#   end
#
# == Extracting all text
#
#   reader = PDF::Reader.new("somefile.pdf")
#
#   reader.pages.map(&:text)
#
# == Extracting content from a single page
#
#   reader = PDF::Reader.new("somefile.pdf")
#
#   page = reader.page(1)
#   puts page.fonts
#   puts page.images
#   puts page.text
#
# == Low level callbacks (ala current version of PDF::Reader)
#
#   reader = PDF::Reader.new("somefile.pdf")
#
#   page = reader.page(1)
#   page.walk(receiver)
#
# == Encrypted Files
#
# Depending on the algorithm it may be possible to parse an encrypted file.
# For standard PDF encryption you'll need the :password option
#
#   reader = PDF::Reader.new("somefile.pdf", :password => "apples")
#
# source://pdf-reader//lib/pdf/reader.rb#95
class PDF::Reader
  # creates a new document reader for the provided PDF.
  #
  # input can be an IO-ish object (StringIO, File, etc) containing a PDF
  # or a filename
  #
  #   reader = PDF::Reader.new("somefile.pdf")
  #
  #   File.open("somefile.pdf","rb") do |file|
  #     reader = PDF::Reader.new(file)
  #   end
  #
  # If the source file is encrypted you can provide a password for decrypting
  #
  #   reader = PDF::Reader.new("somefile.pdf", :password => "apples")
  #
  # Using this method directly is supported, but it's more common to use
  # `PDF::Reader.open`
  #
  #
  # source://pdf-reader//lib/pdf/reader.rb#120
  sig { params(input: T.any(::IO, ::String, ::StringIO, ::Tempfile), opts: T::Hash[T.untyped, T.untyped]).void }
  def initialize(input, opts = T.unsafe(nil)); end

  # Return a Hash with some basic information about the PDF file
  #
  #
  # source://pdf-reader//lib/pdf/reader.rb#131
  sig { returns(T.nilable(T::Hash[T.untyped, T.untyped])) }
  def info; end

  # Return a String with extra XML metadata provided by the author of the PDF file. Not
  # always present.
  #
  #
  # source://pdf-reader//lib/pdf/reader.rb#140
  sig { returns(T.nilable(::String)) }
  def metadata; end

  # lowlevel hash-like access to all objects in the underlying PDF
  #
  # source://pdf-reader//lib/pdf/reader.rb#99
  sig { returns(::PDF::Reader::ObjectHash) }
  def objects; end

  # returns a single PDF::Reader::Page for the specified page.
  # Use this instead of pages method when you need to access just a single
  # page
  #
  #   reader = PDF::Reader.new("somefile.pdf")
  #   page   = reader.page(10)
  #
  #   puts page.text
  #
  # See the docs for PDF::Reader::Page to read more about the
  # methods available on each page
  #
  #
  # source://pdf-reader//lib/pdf/reader.rb#227
  sig { params(num: ::Integer).returns(::PDF::Reader::Page) }
  def page(num); end

  # To number of pages in this PDF
  #
  #
  # source://pdf-reader//lib/pdf/reader.rb#154
  sig { returns(::Integer) }
  def page_count; end

  # returns an array of PDF::Reader::Page objects, one for each
  # page in the source PDF.
  #
  #   reader = PDF::Reader.new("somefile.pdf")
  #
  #   reader.pages.each do |page|
  #     puts page.fonts
  #     puts page.rectangles
  #     puts page.text
  #   end
  #
  # See the docs for PDF::Reader::Page to read more about the
  # methods available on each page
  #
  #
  # source://pdf-reader//lib/pdf/reader.rb#202
  sig { returns(T::Array[::PDF::Reader::Page]) }
  def pages; end

  # The PDF version this file uses
  #
  #
  # source://pdf-reader//lib/pdf/reader.rb#165
  sig { returns(::Float) }
  def pdf_version; end

  private

  # recursively convert strings from outside a content stream into UTF-8
  #
  #
  # source://pdf-reader//lib/pdf/reader.rb#240
  sig { params(obj: T.untyped).returns(T.untyped) }
  def doc_strings_to_utf8(obj); end

  # source://pdf-reader//lib/pdf/reader.rb#262
  sig { params(str: ::String).returns(T::Boolean) }
  def has_utf16_bom?(str); end

  # TODO find a PDF I can use to spec this behaviour
  #
  #
  # source://pdf-reader//lib/pdf/reader.rb#273
  sig { params(obj: ::String).returns(::String) }
  def pdfdoc_to_utf8(obj); end

  # source://pdf-reader//lib/pdf/reader.rb#290
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def root; end

  # one day we'll all run on a 1.9 compatible VM and I can just do this with
  # String#encode
  #
  #
  # source://pdf-reader//lib/pdf/reader.rb#282
  sig { params(obj: ::String).returns(::String) }
  def utf16_to_utf8(obj); end

  class << self
    # syntactic sugar for opening a PDF file and the most common approach. Accepts the
    # same arguments as new().
    #
    #   PDF::Reader.open("somefile.pdf") do |reader|
    #     puts reader.pdf_version
    #   end
    #
    # or
    #
    #   PDF::Reader.open("somefile.pdf", :password => "apples") do |reader|
    #     puts reader.pdf_version
    #   end
    #
    #
    # @yield [PDF::Reader.new(input, opts)]
    #
    # source://pdf-reader//lib/pdf/reader.rb#183
    sig do
      params(
        input: T.any(::IO, ::String, ::Tempfile),
        opts: T::Hash[T.untyped, T.untyped],
        block: T.proc.params(arg0: ::PDF::Reader).void
      ).returns(T.untyped)
    end
    def open(input, opts = T.unsafe(nil), &block); end
  end
end

# Filter a collection of TextRun objects based on a set of conditions.
# It can be used to filter text runs based on their attributes.
# The filter can return the text runs that matches the conditions (only) or
# the text runs that do not match the conditions (exclude).
#
# You can filter the text runs based on all its attributes with the operators
# mentioned in VALID_OPERATORS.
# The filter can be nested with 'or' and 'and' conditions.
#
# Examples:
# 1. Single condition
# AdvancedTextRunFilter.exclude(text_runs, text: { include: 'sample' })
#
# 2. Multiple conditions (and)
# AdvancedTextRunFilter.exclude(text_runs, {
#   font_size: { greater_than: 10, less_than: 15 }
# })
#
# 3. Multiple possible values (or)
# AdvancedTextRunFilter.exclude(text_runs, {
#  font_size: { equal: [10, 12] }
# })
#
# 4. Complex AND/OR filter
# AdvancedTextRunFilter.exclude(text_runs, {
#   and: [
#     { font_size: { greater_than: 10 } },
#     { or: [
#       { text: { include: "sample" } },
#       { width: { greater_than: 100 } }
#     ]}
#   ]
# })
#
# source://pdf-reader//lib/pdf/reader/advanced_text_run_filter.rb#39
class PDF::Reader::AdvancedTextRunFilter
  # source://pdf-reader//lib/pdf/reader/advanced_text_run_filter.rb#68
  sig { params(text_runs: T::Array[::PDF::Reader::TextRun], filter_hash: T::Hash[::Symbol, T.untyped]).void }
  def initialize(text_runs, filter_hash); end

  # source://pdf-reader//lib/pdf/reader/advanced_text_run_filter.rb#80
  sig { returns(T::Array[::PDF::Reader::TextRun]) }
  def exclude; end

  # source://pdf-reader//lib/pdf/reader/advanced_text_run_filter.rb#65
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def filter_hash; end

  # source://pdf-reader//lib/pdf/reader/advanced_text_run_filter.rb#74
  sig { returns(T::Array[::PDF::Reader::TextRun]) }
  def only; end

  # source://pdf-reader//lib/pdf/reader/advanced_text_run_filter.rb#62
  sig { returns(T::Array[::PDF::Reader::TextRun]) }
  def text_runs; end

  private

  # source://pdf-reader//lib/pdf/reader/advanced_text_run_filter.rb#131
  sig { params(attribute_value: T.untyped, operator: ::Symbol, filter_value: T.untyped).returns(T::Boolean) }
  def apply_operator(attribute_value, operator, filter_value); end

  # source://pdf-reader//lib/pdf/reader/advanced_text_run_filter.rb#106
  sig do
    params(
      text_run: ::PDF::Reader::TextRun,
      conditions: T::Array[T::Hash[::Symbol, T.untyped]]
    ).returns(T::Boolean)
  end
  def evaluate_and_filters(text_run, conditions); end

  # source://pdf-reader//lib/pdf/reader/advanced_text_run_filter.rb#120
  sig do
    params(
      text_run: ::PDF::Reader::TextRun,
      attribute: ::Symbol,
      conditions: T::Hash[::Symbol, T.untyped]
    ).returns(T::Boolean)
  end
  def evaluate_attribute_conditions(text_run, attribute, conditions); end

  # source://pdf-reader//lib/pdf/reader/advanced_text_run_filter.rb#88
  sig { params(text_run: ::PDF::Reader::TextRun).returns(T::Boolean) }
  def evaluate_filter(text_run); end

  # source://pdf-reader//lib/pdf/reader/advanced_text_run_filter.rb#113
  sig { params(text_run: ::PDF::Reader::TextRun, filter_hash: T::Hash[::Symbol, T.untyped]).returns(T::Boolean) }
  def evaluate_filters(text_run, filter_hash); end

  # source://pdf-reader//lib/pdf/reader/advanced_text_run_filter.rb#99
  sig do
    params(
      text_run: ::PDF::Reader::TextRun,
      conditions: T::Array[T::Hash[::Symbol, T.untyped]]
    ).returns(T::Boolean)
  end
  def evaluate_or_filters(text_run, conditions); end

  class << self
    # source://pdf-reader//lib/pdf/reader/advanced_text_run_filter.rb#57
    sig do
      params(
        text_runs: T::Array[::PDF::Reader::TextRun],
        filter_hash: T::Hash[::Symbol, T.untyped]
      ).returns(T::Array[::PDF::Reader::TextRun])
    end
    def exclude(text_runs, filter_hash); end

    # source://pdf-reader//lib/pdf/reader/advanced_text_run_filter.rb#52
    sig do
      params(
        text_runs: T::Array[::PDF::Reader::TextRun],
        filter_hash: T::Hash[::Symbol, T.untyped]
      ).returns(T::Array[::PDF::Reader::TextRun])
    end
    def only(text_runs, filter_hash); end
  end
end

# source://pdf-reader//lib/pdf/reader/advanced_text_run_filter.rb#40
PDF::Reader::AdvancedTextRunFilter::VALID_OPERATORS = T.let(T.unsafe(nil), Array)

# Decrypts data using the AESV2 algorithim defined in the PDF spec. Requires
# a decryption key, which is usually generated by PDF::Reader::StandardKeyBuilder
#
# source://pdf-reader//lib/pdf/reader/aes_v2_security_handler.rb#12
class PDF::Reader::AesV2SecurityHandler
  # source://pdf-reader//lib/pdf/reader/aes_v2_security_handler.rb#15
  sig { params(key: ::String).void }
  def initialize(key); end

  # 7.6.2 General Encryption Algorithm
  #
  # Algorithm 1: Encryption of data using the AES-128-CBC algorithm
  #
  # version == 4 and CFM == AESV2
  #
  # used to decrypt PDF streams (buf). Input data should be in bytesizes of
  # a multiple of 16, anything else is an error. The first 16 bytes are the initialization
  # vector, so any input of exactly 16 bytes decrypts to an empty string
  #
  # buf - a string to decrypt
  # ref - a PDF::Reader::Reference for the object to decrypt
  #
  #
  # source://pdf-reader//lib/pdf/reader/aes_v2_security_handler.rb#33
  sig { params(buf: ::String, ref: ::PDF::Reader::Reference).returns(::String) }
  def decrypt(buf, ref); end

  private

  # source://pdf-reader//lib/pdf/reader/aes_v2_security_handler.rb#56
  sig { params(buf: ::String, ref: ::PDF::Reader::Reference, padding: T::Boolean).returns(::String) }
  def internal_decrypt(buf, ref, padding = T.unsafe(nil)); end
end

# Decrypts data using the AESV3 algorithim defined in the PDF 1.7, Extension Level 3 spec.
# Requires a decryption key, which is usually generated by PDF::Reader::KeyBuilderV5
#
# source://pdf-reader//lib/pdf/reader/aes_v3_security_handler.rb#13
class PDF::Reader::AesV3SecurityHandler
  # source://pdf-reader//lib/pdf/reader/aes_v3_security_handler.rb#16
  sig { params(key: ::String).void }
  def initialize(key); end

  # 7.6.2 General Encryption Algorithm
  #
  # Algorithm 1: Encryption of data using the RC4 or AES algorithms
  #
  # used to decrypt RC4/AES encrypted PDF streams (buf). Input data should be in bytesizes of
  # a multiple of 16, anything else is an error. The first 16 bytes are the initialization
  # vector, so any input of exactly 16 bytes decrypts to an empty string
  #
  # buf - a string to decrypt
  # ref - a PDF::Reader::Reference for the object to decrypt
  #
  #
  # source://pdf-reader//lib/pdf/reader/aes_v3_security_handler.rb#38
  sig { params(buf: ::String, ref: ::PDF::Reader::Reference).returns(::String) }
  def decrypt(buf, ref); end

  private

  # source://pdf-reader//lib/pdf/reader/aes_v3_security_handler.rb#61
  sig { params(buf: ::String, ref: ::PDF::Reader::Reference, padding: T::Boolean).returns(::String) }
  def internal_decrypt(buf, ref, padding = T.unsafe(nil)); end
end

# Filter our text/characters that are positioned outside a rectangle. Usually the page
# MediaBox or CropBox, but could be a user specified rectangle too
#
# source://pdf-reader//lib/pdf/reader/bounding_rectangle_runs_filter.rb#9
class PDF::Reader::BoundingRectangleRunsFilter
  class << self
    # source://pdf-reader//lib/pdf/reader/bounding_rectangle_runs_filter.rb#12
    sig do
      params(
        runs: T::Array[::PDF::Reader::TextRun],
        rect: ::PDF::Reader::Rectangle
      ).returns(T::Array[::PDF::Reader::TextRun])
    end
    def runs_within_rect(runs, rect); end
  end
end

# A string tokeniser that recognises PDF grammar. When passed an IO stream or a
# string, repeated calls to token() will return the next token from the source.
#
# This is very low level, and getting the raw tokens is not very useful in itself.
#
# This will usually be used in conjunction with PDF:Reader::Parser, which converts
# the raw tokens into objects we can work with (strings, ints, arrays, etc)
#
# source://pdf-reader//lib/pdf/reader/buffer.rb#40
class PDF::Reader::Buffer
  # Creates a new buffer.
  #
  # Params:
  #
  #   io - an IO stream (usually a StringIO) with the raw data to tokenise
  #
  # options:
  #
  #   :seek - a byte offset to seek to before starting to tokenise
  #   :content_stream - set to true if buffer will be tokenising a
  #                     content stream. Defaults to false
  #
  #
  # source://pdf-reader//lib/pdf/reader/buffer.rb#81
  sig { params(io: T.any(::IO, ::StringIO, ::Tempfile), opts: T::Hash[::Symbol, T.untyped]).void }
  def initialize(io, opts = T.unsafe(nil)); end

  # return true if there are no more tokens left
  #
  #
  # source://pdf-reader//lib/pdf/reader/buffer.rb#93
  sig { returns(T::Boolean) }
  def empty?; end

  # return the byte offset where the first XRef table in th source can be found.
  #
  #
  # @raise [MalformedPDFError]
  #
  # source://pdf-reader//lib/pdf/reader/buffer.rb#150
  sig { returns(::Integer) }
  def find_first_xref_offset; end

  # source://pdf-reader//lib/pdf/reader/buffer.rb#66
  sig { returns(::Integer) }
  def pos; end

  # return raw bytes from the underlying IO stream.
  #
  #   bytes - the number of bytes to read
  #
  # options:
  #
  #   :skip_eol - if true, the IO stream is advanced past a CRLF, CR or LF
  #               that is sitting under the io cursor.
  #   Note:
  #   Skipping a bare CR is not spec-compliant.
  #   This is because the data may start with LF.
  #   However we check for CRLF first, so the ambiguity is avoided.
  #
  # source://pdf-reader//lib/pdf/reader/buffer.rb#112
  sig { params(bytes: ::Integer, opts: T::Hash[::Symbol, T.untyped]).returns(T.nilable(::String)) }
  def read(bytes, opts = T.unsafe(nil)); end

  # return the next token from the source. Returns a string if a token
  # is found, nil if there are no tokens left.
  #
  #
  # source://pdf-reader//lib/pdf/reader/buffer.rb#138
  sig { returns(T.nilable(T.any(::PDF::Reader::Reference, ::String))) }
  def token; end

  private

  # source://pdf-reader//lib/pdf/reader/buffer.rb#174
  sig { void }
  def check_size_is_non_zero; end

  # Returns true if this buffer is parsing a content stream
  #
  #
  # source://pdf-reader//lib/pdf/reader/buffer.rb#184
  sig { returns(T::Boolean) }
  def in_content_stream?; end

  # detect a series of 3 tokens that make up an indirect object. If we find
  # them, replace the tokens with a PDF::Reader::Reference instance.
  #
  # Merging them into a single string was another option, but that would mean
  # code further up the stack would need to check every token  to see if it looks
  # like an indirect object. For optimisation reasons, I'd rather avoid
  # that extra check.
  #
  # It's incredibly likely that the next 3 tokens in the buffer are NOT an
  # indirect reference, so test for that case first and avoid the relatively
  # expensive regexp checks if possible.
  #
  #
  # source://pdf-reader//lib/pdf/reader/buffer.rb#252
  sig { void }
  def merge_indirect_reference; end

  # peek at the next character in the io stream, leaving the stream position
  # untouched
  #
  #
  # source://pdf-reader//lib/pdf/reader/buffer.rb#456
  sig { returns(T.nilable(::Integer)) }
  def peek_byte; end

  # if we're currently inside a hex string, read hex nibbles until
  # we find a closing >
  #
  #
  # source://pdf-reader//lib/pdf/reader/buffer.rb#317
  sig { void }
  def prepare_hex_token; end

  # Extract data between ID and EI
  # If the EI follows white-space the space is dropped from the data
  # The EI must followed by white-space or end of buffer
  # This is to reduce the chance of accidentally matching an embedded EI
  #
  # source://pdf-reader//lib/pdf/reader/buffer.rb#270
  sig { void }
  def prepare_inline_token; end

  # if we're currently inside a literal string we more or less just read bytes until
  # we find the closing ) delimiter. Lots of bytes that would otherwise indicate the
  # start of a new token in regular mode are left untouched when inside a literal
  # string.
  #
  # The entire literal string will be returned as a single token. It will need further
  # processing to fix things like escaped new lines, but that's someone else's
  # problem.
  #
  #
  # source://pdf-reader//lib/pdf/reader/buffer.rb#347
  sig { void }
  def prepare_literal_token; end

  # Extract the next regular token and stock it in our buffer, ready to be returned.
  #
  # What each byte means is complex, check out section "3.1.1 Character Set" of the 1.7 spec
  # to read up on it.
  #
  #
  # source://pdf-reader//lib/pdf/reader/buffer.rb#378
  sig { void }
  def prepare_regular_token; end

  # attempt to prime the buffer with the next few tokens.
  #
  #
  # source://pdf-reader//lib/pdf/reader/buffer.rb#206
  sig { void }
  def prepare_tokens; end

  # Some bastard moved our IO stream cursor. Restore it.
  #
  #
  # source://pdf-reader//lib/pdf/reader/buffer.rb#191
  sig { void }
  def reset_pos; end

  # save the current position of the source IO stream. If someone else (like another buffer)
  # moves the cursor, we can then restore it.
  #
  #
  # source://pdf-reader//lib/pdf/reader/buffer.rb#199
  sig { void }
  def save_pos; end

  # tokenising behaves slightly differently based on the current context.
  # Determine the current context/state by examining the last token we found
  #
  #
  # source://pdf-reader//lib/pdf/reader/buffer.rb#223
  sig { returns(::Symbol) }
  def state; end
end

# source://pdf-reader//lib/pdf/reader/buffer.rb#52
PDF::Reader::Buffer::CR = T.let(T.unsafe(nil), String)

# source://pdf-reader//lib/pdf/reader/buffer.rb#54
PDF::Reader::Buffer::CRLF = T.let(T.unsafe(nil), String)

# must match whole tokens
#
# source://pdf-reader//lib/pdf/reader/buffer.rb#63
PDF::Reader::Buffer::DIGITS_ONLY = T.let(T.unsafe(nil), Regexp)

# source://pdf-reader//lib/pdf/reader/buffer.rb#50
PDF::Reader::Buffer::FWD_SLASH = T.let(T.unsafe(nil), String)

# source://pdf-reader//lib/pdf/reader/buffer.rb#49
PDF::Reader::Buffer::ID = T.let(T.unsafe(nil), String)

# some strings for comparissons. Declaring them here avoids creating new
# strings that need GC over and over
#
# source://pdf-reader//lib/pdf/reader/buffer.rb#46
PDF::Reader::Buffer::LEFT_PAREN = T.let(T.unsafe(nil), String)

# source://pdf-reader//lib/pdf/reader/buffer.rb#47
PDF::Reader::Buffer::LESS_THAN = T.let(T.unsafe(nil), String)

# source://pdf-reader//lib/pdf/reader/buffer.rb#53
PDF::Reader::Buffer::LF = T.let(T.unsafe(nil), String)

# source://pdf-reader//lib/pdf/reader/buffer.rb#51
PDF::Reader::Buffer::NULL_BYTE = T.let(T.unsafe(nil), String)

# source://pdf-reader//lib/pdf/reader/buffer.rb#48
PDF::Reader::Buffer::STREAM = T.let(T.unsafe(nil), String)

# source://pdf-reader//lib/pdf/reader/buffer.rb#42
PDF::Reader::Buffer::TOKEN_DELIMITER = T.let(T.unsafe(nil), Array)

# source://pdf-reader//lib/pdf/reader/buffer.rb#41
PDF::Reader::Buffer::TOKEN_WHITESPACE = T.let(T.unsafe(nil), Array)

# Quite a few PDFs have trailing junk.
# This can be several k of nuls in some cases
# Allow for this here
#
# source://pdf-reader//lib/pdf/reader/buffer.rb#60
PDF::Reader::Buffer::TRAILING_BYTECOUNT = T.let(T.unsafe(nil), Integer)

# source://pdf-reader//lib/pdf/reader/buffer.rb#55
PDF::Reader::Buffer::WHITE_SPACE = T.let(T.unsafe(nil), Array)

# wraps a string containing a PDF CMap and provides convenience methods for
# extracting various useful information.
#
# source://pdf-reader//lib/pdf/reader/cmap.rb#35
class PDF::Reader::CMap
  # source://pdf-reader//lib/pdf/reader/cmap.rb#53
  sig { params(data: ::String).void }
  def initialize(data); end

  # Convert a glyph code into one or more Codepoints.
  #
  # Returns an array of Integers.
  #
  #
  # source://pdf-reader//lib/pdf/reader/cmap.rb#68
  sig { params(c: ::Integer).returns(T::Array[::Integer]) }
  def decode(c); end

  # source://pdf-reader//lib/pdf/reader/cmap.rb#50
  sig { returns(T::Hash[::Integer, T::Array[::Integer]]) }
  def map; end

  # source://pdf-reader//lib/pdf/reader/cmap.rb#59
  sig { returns(::Integer) }
  def size; end

  private

  # source://pdf-reader//lib/pdf/reader/cmap.rb#168
  sig { params(start_code: ::String, end_code: ::String, dst: ::String).void }
  def bfrange_type_one(start_code, end_code, dst); end

  # source://pdf-reader//lib/pdf/reader/cmap.rb#182
  sig { params(start_code: ::String, end_code: ::String, dst: T::Array[::String]).void }
  def bfrange_type_two(start_code, end_code, dst); end

  # source://pdf-reader//lib/pdf/reader/cmap.rb#105
  sig { params(instructions: ::String).returns(::PDF::Reader::Parser) }
  def build_parser(instructions); end

  # source://pdf-reader//lib/pdf/reader/cmap.rb#144
  sig { params(instructions: T::Array[::String]).void }
  def process_bfchar_instructions(instructions); end

  # source://pdf-reader//lib/pdf/reader/cmap.rb#155
  sig { params(instructions: T::Array[T.any(::String, T::Array[::String])]).void }
  def process_bfrange_instructions(instructions); end

  # source://pdf-reader//lib/pdf/reader/cmap.rb#75
  sig { params(data: ::String, initial_mode: ::Symbol).void }
  def process_data(data, initial_mode = T.unsafe(nil)); end

  # The following includes some manual decoding of UTF-16BE strings into unicode codepoints. In
  # theory we could replace all the UTF-16 code with something based on Ruby's encoding support:
  #
  #    str.dup.force_encoding("utf-16be").encode!("utf-8").unpack("U*")
  #
  # However, some cmaps contain broken surrogate pairs and the ruby encoding support raises an
  # exception when we try converting broken UTF-16 to UTF-8
  #
  #
  # source://pdf-reader//lib/pdf/reader/cmap.rb#119
  sig { params(str: ::String).returns(T::Array[::Integer]) }
  def str_to_int(str); end
end

# source://pdf-reader//lib/pdf/reader/cmap.rb#37
PDF::Reader::CMap::CMAP_KEYWORDS = T.let(T.unsafe(nil), Hash)

# A Hash-like object that wraps the array of glyph widths in a CID font
# and gives us a nice way to query it for specific widths.
#
# there are two ways to calculate a cidfont_glyph_width, that are defined
# in Section 9.7.4.3 PDF 32000-1:2008 pp 271, the differences are remarked
# on below. because of these difference that may be contained within the
# same array, it is a bit difficult to parse this array.
#
# source://pdf-reader//lib/pdf/reader/cid_widths.rb#15
class PDF::Reader::CidWidths
  extend ::Forwardable

  # source://pdf-reader//lib/pdf/reader/cid_widths.rb#22
  sig { params(default: ::Numeric, array: T::Array[::Numeric]).void }
  def initialize(default, array); end

  # source://pdf-reader//lib/pdf/reader/cid_widths.rb#19
  def [](*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/cid_widths.rb#19
  def fetch(*args, **_arg1, &block); end

  private

  # source://pdf-reader//lib/pdf/reader/cid_widths.rb#29
  sig { params(default: ::Numeric, array: T::Array[::Numeric]).returns(T::Hash[::Numeric, ::Numeric]) }
  def parse_array(default, array); end

  # this is the form 10 [234 63 234 346 47 234] where width of index 10 is
  # 234, index 11 is 63, etc
  #
  #
  # source://pdf-reader//lib/pdf/reader/cid_widths.rb#50
  sig { params(first: ::Integer, widths: T::Array[::Numeric]).returns(T::Hash[::Numeric, ::Numeric]) }
  def parse_first_form(first, widths); end

  # this is the form 10 20 123 where all index between 10 and 20 have width 123
  #
  #
  # source://pdf-reader//lib/pdf/reader/cid_widths.rb#60
  sig { params(first: ::Integer, final: ::Integer, width: ::Numeric).returns(T::Hash[::Numeric, ::Numeric]) }
  def parse_second_form(first, final, width); end
end

# Util class for working with string encodings in PDF files. Mostly used to
# convert strings of various PDF-dialect encodings into UTF-8.
#
# source://pdf-reader//lib/pdf/reader/encoding.rb#33
class PDF::Reader::Encoding
  # source://pdf-reader//lib/pdf/reader/encoding.rb#42
  sig { params(enc: T.nilable(T.any(::Symbol, T::Hash[::Symbol, T.untyped]))).void }
  def initialize(enc); end

  # source://pdf-reader//lib/pdf/reader/encoding.rb#96
  sig { returns(T::Hash[::Integer, ::Integer]) }
  def differences; end

  # set the differences table for this encoding. should be an array in the following format:
  #
  #   [25, :A, 26, :B]
  #
  # The array alternates between a decimal byte number and a glyph name to map to that byte
  #
  # To save space the following array is also valid and equivalent to the previous one
  #
  #   [25, :A, :B]
  #
  # source://pdf-reader//lib/pdf/reader/encoding.rb#78
  sig { params(diff: T::Array[T.any(::Integer, ::Symbol)]).returns(T::Hash[::Integer, ::Integer]) }
  def differences=(diff); end

  # convert an integer glyph code into an Adobe glyph name.
  #
  #     int_to_name(65)
  #     => [:A]
  #
  #
  # source://pdf-reader//lib/pdf/reader/encoding.rb#132
  sig { params(glyph_code: ::Integer).returns(T::Array[::Symbol]) }
  def int_to_name(glyph_code); end

  # source://pdf-reader//lib/pdf/reader/encoding.rb#122
  sig { params(glyph_code: ::Integer).returns(::String) }
  def int_to_utf8_string(glyph_code); end

  # convert the specified string to utf8
  #
  # * unpack raw bytes into codepoints
  # * replace any that have entries in the differences table with a glyph name
  # * convert codepoints from source encoding to Unicode codepoints
  # * convert any glyph names to Unicode codepoints
  # * replace characters that didn't convert to Unicode nicely with something
  #   valid
  # * pack the final array of Unicode codepoints into a utf-8 string
  # * mark the string as utf-8 if we're running on a M17N aware VM
  #
  #
  # source://pdf-reader//lib/pdf/reader/encoding.rb#113
  sig { params(str: ::String).returns(::String) }
  def to_utf8(str); end

  # source://pdf-reader//lib/pdf/reader/encoding.rb#39
  sig { returns(::String) }
  def unpack; end

  private

  # source://pdf-reader//lib/pdf/reader/encoding.rb#189
  sig { params(str: ::String).returns(::String) }
  def convert_to_utf8(str); end

  # returns a hash that:
  # - maps control chars and nil to the unicode "unknown character"
  # - leaves all other bytes <= 255 unchaged
  #
  # Each specific encoding will change this default as required for their glyphs
  #
  # source://pdf-reader//lib/pdf/reader/encoding.rb#157
  sig { returns(T::Hash[::Integer, ::Integer]) }
  def default_mapping; end

  # source://pdf-reader//lib/pdf/reader/encoding.rb#206
  sig { params(enc: ::Symbol).returns(T.nilable(::String)) }
  def get_mapping_file(enc); end

  # source://pdf-reader//lib/pdf/reader/encoding.rb#196
  sig { params(enc: ::Symbol).returns(::String) }
  def get_unpack(enc); end

  # source://pdf-reader//lib/pdf/reader/encoding.rb#228
  sig { returns(::PDF::Reader::GlyphHash) }
  def glyphlist; end

  # source://pdf-reader//lib/pdf/reader/encoding.rb#167
  sig { params(glyph_code: ::Integer).returns(::String) }
  def internal_int_to_utf8_string(glyph_code); end

  # source://pdf-reader//lib/pdf/reader/encoding.rb#181
  sig { params(times: ::Integer).returns(::String) }
  def little_boxes(times); end

  # source://pdf-reader//lib/pdf/reader/encoding.rb#233
  sig { params(file: ::String).void }
  def load_mapping(file); end

  # source://pdf-reader//lib/pdf/reader/encoding.rb#176
  sig { returns(T::Boolean) }
  def utf8_conversion_impossible?; end
end

# source://pdf-reader//lib/pdf/reader/encoding.rb#34
PDF::Reader::Encoding::CONTROL_CHARS = T.let(T.unsafe(nil), Array)

# source://pdf-reader//lib/pdf/reader/encoding.rb#36
PDF::Reader::Encoding::UNKNOWN_CHAR = T.let(T.unsafe(nil), Integer)

# an exception that is raised when a PDF is encrypted and we don't have the
# necessary data to decrypt it
#
# source://pdf-reader//lib/pdf/reader/error.rb#90
class PDF::Reader::EncryptedPDFError < ::PDF::Reader::UnsupportedFeatureError; end

# An internal PDF::Reader class that helps to verify various parts of the PDF file
# are valid
#
# source://pdf-reader//lib/pdf/reader/error.rb#32
class PDF::Reader::Error
  class << self
    # @raise [MalformedPDFError]
    #
    # source://pdf-reader//lib/pdf/reader/error.rb#49
    sig { params(lvalue: T.untyped, rvalue: T.untyped).returns(T.untyped) }
    def assert_equal(lvalue, rvalue); end

    # @raise [MalformedPDFError]
    #
    # source://pdf-reader//lib/pdf/reader/error.rb#35
    sig { params(lvalue: T.untyped, rvalue: T.untyped, chars: T.untyped).returns(T.untyped) }
    def str_assert(lvalue, rvalue, chars = T.unsafe(nil)); end

    # @raise [MalformedPDFError]
    #
    # source://pdf-reader//lib/pdf/reader/error.rb#42
    sig { params(lvalue: T.untyped, rvalue: T.untyped, chars: T.untyped).returns(T.untyped) }
    def str_assert_not(lvalue, rvalue, chars = T.unsafe(nil)); end

    # @raise [ArgumentError]
    #
    # source://pdf-reader//lib/pdf/reader/error.rb#64
    sig { params(object: ::Object, name: ::String).void }
    def validate_not_nil(object, name); end

    # @raise [ArgumentError]
    #
    # source://pdf-reader//lib/pdf/reader/error.rb#54
    sig { params(object: ::Object, name: ::String, klass: ::Module).void }
    def validate_type(object, name, klass); end

    # @raise [MalformedPDFError]
    #
    # source://pdf-reader//lib/pdf/reader/error.rb#59
    sig { params(object: ::Object, name: ::String, klass: ::Module).void }
    def validate_type_as_malformed(object, name, klass); end
  end
end

# Utility class used to avoid modifying the underlying TextRun objects while we're
# looking for duplicates
#
# source://pdf-reader//lib/pdf/reader/overlapping_runs_filter.rb#58
class PDF::Reader::EventPoint
  # source://pdf-reader//lib/pdf/reader/overlapping_runs_filter.rb#67
  sig { params(x: ::Numeric, run: ::PDF::Reader::TextRun).void }
  def initialize(x, run); end

  # source://pdf-reader//lib/pdf/reader/overlapping_runs_filter.rb#64
  sig { returns(::PDF::Reader::TextRun) }
  def run; end

  # source://pdf-reader//lib/pdf/reader/overlapping_runs_filter.rb#73
  sig { returns(T::Boolean) }
  def start?; end

  # source://pdf-reader//lib/pdf/reader/overlapping_runs_filter.rb#61
  sig { returns(::Numeric) }
  def x; end
end

# Various parts of a PDF file can be passed through a filter before being stored to provide
# support for features like compression and encryption. This class is for decoding that
# content.
#
# source://pdf-reader//lib/pdf/reader/filter.rb#36
module PDF::Reader::Filter
  class << self
    # creates a new filter for decoding content.
    #
    # Filters that are only used to encode image data are accepted, but the data is
    # returned untouched. At this stage PDF::Reader has no need to decode images.
    #
    #
    # source://pdf-reader//lib/pdf/reader/filter.rb#45
    sig { params(name: ::Symbol, options: T::Hash[T.untyped, T.untyped]).returns(T.untyped) }
    def with(name, options = T.unsafe(nil)); end
  end
end

# implementation of the Ascii85 filter
#
# source://pdf-reader//lib/pdf/reader/filter/ascii85.rb#10
class PDF::Reader::Filter::Ascii85
  # source://pdf-reader//lib/pdf/reader/filter/ascii85.rb#13
  sig { params(options: T::Hash[T.untyped, T.untyped]).void }
  def initialize(options = T.unsafe(nil)); end

  # Decode the specified data using the Ascii85 algorithm. Relies on the AScii85
  # rubygem.
  #
  #
  # source://pdf-reader//lib/pdf/reader/filter/ascii85.rb#22
  sig { params(data: ::String).returns(::String) }
  def filter(data); end
end

# implementation of the AsciiHex stream filter
#
# source://pdf-reader//lib/pdf/reader/filter/ascii_hex.rb#9
class PDF::Reader::Filter::AsciiHex
  # source://pdf-reader//lib/pdf/reader/filter/ascii_hex.rb#12
  sig { params(options: T::Hash[T.untyped, T.untyped]).void }
  def initialize(options = T.unsafe(nil)); end

  # Decode the specified data using the AsciiHex algorithm.
  #
  #
  # source://pdf-reader//lib/pdf/reader/filter/ascii_hex.rb#20
  sig { params(data: ::String).returns(::String) }
  def filter(data); end
end

# some filter implementations support preprocessing of the  data to
# improve compression
#
# source://pdf-reader//lib/pdf/reader/filter/depredict.rb#9
class PDF::Reader::Filter::Depredict
  # source://pdf-reader//lib/pdf/reader/filter/depredict.rb#12
  sig { params(options: T::Hash[T.untyped, T.untyped]).void }
  def initialize(options = T.unsafe(nil)); end

  # Streams can be preprocessed to improve compression. This reverses the
  # preprocessing
  #
  #
  # source://pdf-reader//lib/pdf/reader/filter/depredict.rb#21
  sig { params(data: ::String).returns(::String) }
  def filter(data); end

  private

  # source://pdf-reader//lib/pdf/reader/filter/depredict.rb#67
  sig { params(data: T.untyped).returns(::String) }
  def png_depredict(data); end

  # source://pdf-reader//lib/pdf/reader/filter/depredict.rb#40
  sig { params(data: T.untyped).returns(::String) }
  def tiff_depredict(data); end
end

# implementation of the Flate (zlib) stream filter
#
# source://pdf-reader//lib/pdf/reader/filter/flate.rb#11
class PDF::Reader::Filter::Flate
  # source://pdf-reader//lib/pdf/reader/filter/flate.rb#17
  sig { params(options: T::Hash[T.untyped, T.untyped]).void }
  def initialize(options = T.unsafe(nil)); end

  # Decode the specified data with the Zlib compression algorithm
  #
  # source://pdf-reader//lib/pdf/reader/filter/flate.rb#24
  sig { params(data: ::String).returns(::String) }
  def filter(data); end

  private

  # source://pdf-reader//lib/pdf/reader/filter/flate.rb#37
  sig { params(data: T.untyped).returns(T.untyped) }
  def zlib_inflate(data); end
end

# source://pdf-reader//lib/pdf/reader/filter/flate.rb#13
PDF::Reader::Filter::Flate::ZLIB_AUTO_DETECT_ZLIB_OR_GZIP = T.let(T.unsafe(nil), Integer)

# source://pdf-reader//lib/pdf/reader/filter/flate.rb#14
PDF::Reader::Filter::Flate::ZLIB_RAW_DEFLATE = T.let(T.unsafe(nil), Integer)

# implementation of the LZW stream filter
#
# source://pdf-reader//lib/pdf/reader/filter/lzw.rb#9
class PDF::Reader::Filter::Lzw
  # source://pdf-reader//lib/pdf/reader/filter/lzw.rb#12
  sig { params(options: T::Hash[T.untyped, T.untyped]).void }
  def initialize(options = T.unsafe(nil)); end

  # Decode the specified data with the LZW compression algorithm
  #
  # source://pdf-reader//lib/pdf/reader/filter/lzw.rb#19
  sig { params(data: ::String).returns(::String) }
  def filter(data); end
end

# implementation of the null stream filter
#
# source://pdf-reader//lib/pdf/reader/filter/null.rb#8
class PDF::Reader::Filter::Null
  # source://pdf-reader//lib/pdf/reader/filter/null.rb#10
  sig { params(options: T::Hash[T.untyped, T.untyped]).void }
  def initialize(options = T.unsafe(nil)); end

  # source://pdf-reader//lib/pdf/reader/filter/null.rb#15
  sig { params(data: ::String).returns(::String) }
  def filter(data); end
end

# implementation of the run length stream filter
#
# source://pdf-reader//lib/pdf/reader/filter/run_length.rb#9
class PDF::Reader::Filter::RunLength
  # source://pdf-reader//lib/pdf/reader/filter/run_length.rb#12
  sig { params(options: T::Hash[T.untyped, T.untyped]).void }
  def initialize(options = T.unsafe(nil)); end

  # Decode the specified data with the RunLengthDecode compression algorithm
  #
  # source://pdf-reader//lib/pdf/reader/filter/run_length.rb#19
  sig { params(data: ::String).returns(::String) }
  def filter(data); end
end

# Represents a single font PDF object and provides some useful methods
# for extracting info. Mainly used for converting text to UTF-8.
#
# source://pdf-reader//lib/pdf/reader/font.rb#37
class PDF::Reader::Font
  # source://pdf-reader//lib/pdf/reader/font.rb#80
  sig { params(ohash: ::PDF::Reader::ObjectHash, obj: T::Hash[::Symbol, T.untyped]).void }
  def initialize(ohash, obj); end

  # source://pdf-reader//lib/pdf/reader/font.rb#68
  sig { returns(T.nilable(::Symbol)) }
  def basefont; end

  # source://pdf-reader//lib/pdf/reader/font.rb#77
  sig { returns(::Numeric) }
  def cid_default_width; end

  # source://pdf-reader//lib/pdf/reader/font.rb#74
  sig { returns(T::Array[::Numeric]) }
  def cid_widths; end

  # source://pdf-reader//lib/pdf/reader/font.rb#53
  sig { returns(T::Array[::PDF::Reader::Font]) }
  def descendantfonts; end

  # source://pdf-reader//lib/pdf/reader/font.rb#53
  def descendantfonts=(_arg0); end

  # source://pdf-reader//lib/pdf/reader/font.rb#50
  sig { returns(::PDF::Reader::Encoding) }
  def encoding; end

  # source://pdf-reader//lib/pdf/reader/font.rb#50
  def encoding=(_arg0); end

  # source://pdf-reader//lib/pdf/reader/font.rb#62
  sig { returns(T.nilable(::Integer)) }
  def first_char; end

  # source://pdf-reader//lib/pdf/reader/font.rb#71
  sig { returns(T.nilable(::PDF::Reader::FontDescriptor)) }
  def font_descriptor; end

  # looks up the specified codepoint and returns a value that is in (pdf)
  # glyph space, which is 1000 glyph units = 1 text space unit
  #
  # source://pdf-reader//lib/pdf/reader/font.rb#119
  sig { params(code_point: T.any(::Integer, ::String)).returns(::Numeric) }
  def glyph_width(code_point); end

  # In most cases glyph width is converted into text space with a simple divide by 1000.
  #
  # However, Type3 fonts provide their own FontMatrix that's used for the transformation.
  #
  #
  # source://pdf-reader//lib/pdf/reader/font.rb#133
  sig { params(code_point: T.any(::Integer, ::String)).returns(::Numeric) }
  def glyph_width_in_text_space(code_point); end

  # source://pdf-reader//lib/pdf/reader/font.rb#65
  sig { returns(T.nilable(::Integer)) }
  def last_char; end

  # source://pdf-reader//lib/pdf/reader/font.rb#47
  sig { returns(T.nilable(::Symbol)) }
  def subtype; end

  # source://pdf-reader//lib/pdf/reader/font.rb#47
  def subtype=(_arg0); end

  # source://pdf-reader//lib/pdf/reader/font.rb#103
  sig { params(params: T.any(::Integer, ::String, T::Array[T.any(::Integer, ::String)])).returns(::String) }
  def to_utf8(params); end

  # source://pdf-reader//lib/pdf/reader/font.rb#56
  sig { returns(T.nilable(::PDF::Reader::CMap)) }
  def tounicode; end

  # source://pdf-reader//lib/pdf/reader/font.rb#56
  def tounicode=(_arg0); end

  # source://pdf-reader//lib/pdf/reader/font.rb#112
  sig { params(data: ::String).returns(T.nilable(T::Array[T.nilable(T.any(::Float, ::Integer, ::String))])) }
  def unpack(data); end

  # source://pdf-reader//lib/pdf/reader/font.rb#59
  sig { returns(T::Array[::Numeric]) }
  def widths; end

  private

  # source://pdf-reader//lib/pdf/reader/font.rb#208
  sig { params(obj: T::Hash[::Symbol, T.untyped]).returns(::PDF::Reader::Encoding) }
  def build_encoding(obj); end

  # source://pdf-reader//lib/pdf/reader/font.rb#181
  sig { returns(T.untyped) }
  def build_width_calculator; end

  # source://pdf-reader//lib/pdf/reader/font.rb#169
  sig { params(font_name: T.nilable(T.any(::String, ::Symbol))).returns(::PDF::Reader::Encoding) }
  def default_encoding(font_name); end

  # source://pdf-reader//lib/pdf/reader/font.rb#223
  sig { params(obj: T::Hash[::Symbol, T.untyped]).void }
  def extract_base_info(obj); end

  # source://pdf-reader//lib/pdf/reader/font.rb#267
  sig { params(obj: T::Hash[::Symbol, T.untyped]).void }
  def extract_descendants(obj); end

  # source://pdf-reader//lib/pdf/reader/font.rb#255
  sig { params(obj: T::Hash[::Symbol, T.untyped]).void }
  def extract_descriptor(obj); end

  # source://pdf-reader//lib/pdf/reader/font.rb#246
  sig { params(obj: T::Hash[::Symbol, T.untyped]).void }
  def extract_type3_info(obj); end

  # Only valid for Type3 fonts
  #
  # source://pdf-reader//lib/pdf/reader/font.rb#149
  sig { params(x: ::Numeric, y: ::Numeric).returns([::Numeric, ::Numeric]) }
  def font_matrix_transform(x, y); end

  # source://pdf-reader//lib/pdf/reader/font.rb#282
  sig do
    params(
      params: T.any(::Integer, ::String, T::Array[T.any(::Integer, ::String)]),
      cmap: ::PDF::Reader::CMap
    ).returns(::String)
  end
  def to_utf8_via_cmap(params, cmap); end

  # source://pdf-reader//lib/pdf/reader/font.rb#298
  sig { params(params: T.any(::Integer, ::String, T::Array[T.any(::Integer, ::String)])).returns(::String) }
  def to_utf8_via_encoding(params); end

  # source://pdf-reader//lib/pdf/reader/font.rb#314
  sig { params(unpack_me: ::String, unpack_arg: ::String).returns(T::Array[::Integer]) }
  def unpack_string_to_array_of_ints(unpack_me, unpack_arg); end
end

# Font descriptors are outlined in Section 9.8, PDF 32000-1:2008, pp 281-288
#
# source://pdf-reader//lib/pdf/reader/font_descriptor.rb#10
class PDF::Reader::FontDescriptor
  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#61
  sig { params(ohash: ::PDF::Reader::ObjectHash, fd_hash: T::Hash[T.untyped, T.untyped]).void }
  def initialize(ohash, fd_hash); end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#31
  sig { returns(::Numeric) }
  def ascent; end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#40
  sig { returns(::Numeric) }
  def avg_width; end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#28
  sig { returns(::Numeric) }
  def cap_height; end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#34
  sig { returns(::Numeric) }
  def descent; end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#25
  sig { returns(T::Array[::Numeric]) }
  def font_bounding_box; end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#16
  sig { returns(T.nilable(::String)) }
  def font_family; end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#58
  sig { returns(::Integer) }
  def font_flags; end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#13
  sig { returns(::String) }
  def font_name; end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#19
  sig { returns(::Symbol) }
  def font_stretch; end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#22
  sig { returns(::Numeric) }
  def font_weight; end

  # PDF states that a glyph is 1000 units wide, true type doesn't enforce
  # any behavior, but uses units/em to define how wide the 'M' is (the widest letter)
  #
  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#118
  sig { returns(::Numeric) }
  def glyph_to_pdf_scale_factor; end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#99
  sig { params(char_code: ::Integer).returns(::Numeric) }
  def glyph_width(char_code); end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#49
  sig { returns(T.nilable(::Numeric)) }
  def italic_angle; end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#37
  sig { returns(::Numeric) }
  def leading; end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#43
  sig { returns(::Numeric) }
  def max_width; end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#46
  sig { returns(::Numeric) }
  def missing_width; end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#52
  sig { returns(T.nilable(::Numeric)) }
  def stem_v; end

  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#55
  sig { returns(T.nilable(::Numeric)) }
  def x_height; end

  private

  # @raise [MalformedPDFError]
  #
  # source://pdf-reader//lib/pdf/reader/font_descriptor.rb#130
  sig { returns(::TTFunk::File) }
  def ttf_program_stream; end
end

# High level representation of a single PDF form xobject. Form xobjects
# are contained pieces of content that can be inserted onto multiple
# pages. They're generally used as a space efficient way to store
# repetative content (like logos, header, footers, etc).
#
# This behaves and looks much like a limited PDF::Reader::Page class.
#
# source://pdf-reader//lib/pdf/reader/form_xobject.rb#17
class PDF::Reader::FormXObject
  extend ::Forwardable

  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#33
  sig { params(page: T.untyped, xobject: T.untyped, options: T::Hash[T.untyped, T.untyped]).void }
  def initialize(page, xobject, options = T.unsafe(nil)); end

  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#23
  def color_spaces(*args, **_arg1, &block); end

  # return a hash of fonts used on this form.
  #
  # The keys are the font labels used within the form content stream.
  #
  # The values are a PDF::Reader::Font instances that provide access
  # to most available metrics for each font.
  #
  #
  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#48
  sig { returns(T.untyped) }
  def font_objects; end

  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#24
  def fonts(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#25
  def graphic_states(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#26
  def patterns(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#27
  def procedure_sets(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#28
  def properties(*args, **_arg1, &block); end

  # returns the raw content stream for this page. This is plumbing, nothing to
  # see here unless you're a PDF nerd like me.
  #
  #
  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#72
  sig { returns(T.untyped) }
  def raw_content; end

  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#29
  def shadings(*args, **_arg1, &block); end

  # processes the raw content stream for this form in sequential order and
  # passes callbacks to the receiver objects.
  #
  # See the comments on PDF::Reader::Page#walk for more detail.
  #
  #
  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#61
  sig { params(receivers: T.untyped).returns(T.untyped) }
  def walk(*receivers); end

  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#21
  sig { returns(T.untyped) }
  def xobject; end

  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#30
  def xobjects(*args, **_arg1, &block); end

  private

  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#98
  sig { returns(T.untyped) }
  def cached_tokens_key; end

  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#86
  sig { params(receivers: T.untyped, name: T.untyped, params: T::Array[T.untyped]).returns(T.untyped) }
  def callback(receivers, name, params = T.unsafe(nil)); end

  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#116
  sig { params(receivers: T.untyped, instructions: T.untyped).returns(T.untyped) }
  def content_stream(receivers, instructions); end

  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#93
  sig { returns(T.untyped) }
  def content_stream_md5; end

  # Returns the resources that accompany this form.
  #
  #
  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#81
  sig { returns(T.untyped) }
  def resources; end

  # source://pdf-reader//lib/pdf/reader/form_xobject.rb#103
  sig { returns(T.untyped) }
  def tokens; end
end

# A Hash-like object that can convert glyph names into a unicode codepoint.
# The mapping is read from a data file on disk the first time it's needed.
#
# source://pdf-reader//lib/pdf/reader/glyph_hash.rb#34
class PDF::Reader::GlyphHash
  # source://pdf-reader//lib/pdf/reader/glyph_hash.rb#54
  sig { void }
  def initialize; end

  # attempt to convert a PDF Name to a unicode codepoint. Returns nil
  # if no conversion is possible.
  #
  #   h = GlyphHash.new
  #
  #   h.name_to_unicode(:A)
  #   => 65
  #
  #   h.name_to_unicode(:Euro)
  #   => 8364
  #
  #   h.name_to_unicode(:X4A)
  #   => 74
  #
  #   h.name_to_unicode(:G30)
  #   => 48
  #
  #   h.name_to_unicode(:34)
  #   => 34
  #
  #
  # source://pdf-reader//lib/pdf/reader/glyph_hash.rb#90
  sig { params(name: T.nilable(::Symbol)).returns(T.nilable(::Integer)) }
  def name_to_unicode(name); end

  # attempt to convert a Unicode code point to the equivilant PDF Name. Returns nil
  # if no conversion is possible.
  #
  #   h = GlyphHash.new
  #
  #   h.unicode_to_name(65)
  #   => [:A]
  #
  #   h.unicode_to_name(8364)
  #   => [:Euro]
  #
  #   h.unicode_to_name(34)
  #   => [:34]
  #
  #
  # source://pdf-reader//lib/pdf/reader/glyph_hash.rb#128
  sig { params(codepoint: ::Integer).returns(T::Array[::Symbol]) }
  def unicode_to_name(codepoint); end

  private

  # returns a hash that maps glyph names to unicode codepoints. The mapping is based on
  # a text file supplied by Adobe at:
  # https://github.com/adobe-type-tools/agl-aglfn
  #
  # source://pdf-reader//lib/pdf/reader/glyph_hash.rb#138
  sig { returns(::PDF::Reader::GlyphHash::ReturnData) }
  def load_adobe_glyph_mapping; end
end

# An internal class for returning multiple pieces of data and keep sorbet happy
#
# source://pdf-reader//lib/pdf/reader/glyph_hash.rb#39
class PDF::Reader::GlyphHash::ReturnData
  # :(Hash[Symbol, Integer], Hash[Integer, Array[Symbol]]) -> void
  #
  # @return [ReturnData] a new instance of ReturnData
  #
  # source://pdf-reader//lib/pdf/reader/glyph_hash.rb#47
  def initialize(by_name, by_codepoint); end

  # source://pdf-reader//lib/pdf/reader/glyph_hash.rb#44
  sig { returns(T::Hash[::Integer, T::Array[::Symbol]]) }
  def by_codepoint; end

  # source://pdf-reader//lib/pdf/reader/glyph_hash.rb#41
  sig { returns(T::Hash[::Symbol, ::Integer]) }
  def by_name; end
end

# an exception that is raised when a PDF object appears to be invalid
#
# source://pdf-reader//lib/pdf/reader/error.rb#80
class PDF::Reader::InvalidObjectError < ::PDF::Reader::MalformedPDFError; end

# an exception that is raised when an invalid page number is used
#
# source://pdf-reader//lib/pdf/reader/error.rb#76
class PDF::Reader::InvalidPageError < ::ArgumentError; end

# Processes the Encrypt dict from an encrypted PDF and a user provided
# password and returns a key that can decrypt the file.
#
# This can generate a decryption key compatible with the following standard encryption algorithms:
#
# * Version 5 (AESV3)
#
# source://pdf-reader//lib/pdf/reader/key_builder_v5.rb#17
class PDF::Reader::KeyBuilderV5
  # source://pdf-reader//lib/pdf/reader/key_builder_v5.rb#20
  sig { params(opts: T::Hash[::Symbol, ::String]).void }
  def initialize(opts = T.unsafe(nil)); end

  # Takes a string containing a user provided password.
  #
  # If the password matches the file, then a string containing a key suitable for
  # decrypting the file will be returned. If the password doesn't match the file,
  # and exception will be raised.
  #
  #
  # @raise [PDF::Reader::EncryptedPDFError]
  #
  # source://pdf-reader//lib/pdf/reader/key_builder_v5.rb#43
  sig { params(pass: ::String).returns(::String) }
  def key(pass); end

  private

  # Algorithm 3.2a - Computing an encryption key
  #
  # Defined in PDF 1.7 Extension Level 3
  #
  # if the string is a valid user/owner password, this will return the decryption key
  #
  #
  # source://pdf-reader//lib/pdf/reader/key_builder_v5.rb#64
  sig { params(password: ::String).returns(T.nilable(::String)) }
  def auth_owner_pass(password); end

  # source://pdf-reader//lib/pdf/reader/key_builder_v5.rb#88
  sig { params(password: ::String).returns(T.nilable(::String)) }
  def auth_owner_pass_r6(password); end

  # source://pdf-reader//lib/pdf/reader/key_builder_v5.rb#76
  sig { params(password: ::String).returns(T.nilable(::String)) }
  def auth_user_pass(password); end

  # source://pdf-reader//lib/pdf/reader/key_builder_v5.rb#100
  sig { params(password: ::String).returns(T.nilable(::String)) }
  def auth_user_pass_r6(password); end

  # PDF 2.0 spec, 7.6.4.3.4
  # Algorithm 2.B: Computing a hash (revision 6 and later)
  #
  # source://pdf-reader//lib/pdf/reader/key_builder_v5.rb#114
  sig { params(password: ::String, salt: ::String, user_key: ::String).returns(::String) }
  def r6_digest(password, salt, user_key = T.unsafe(nil)); end

  # source://pdf-reader//lib/pdf/reader/key_builder_v5.rb#139
  sig { params(str: ::String).returns(::Integer) }
  def unpack_128bit_bigendian_int(str); end
end

# A general class for decoding LZW compressed data. LZW can be
# used in PDF files to compresses streams, usually for image data sourced
# from a TIFF file.
#
# See the following links for more information:
#
#   ref http://www.fileformat.info/format/tiff/corion-lzw.htm
#   ref http://marknelson.us/1989/10/01/lzw-data-compression/
#
# The PDF spec also has some data on the algorithm.
#
# source://pdf-reader//lib/pdf/reader/lzw.rb#20
class PDF::Reader::LZW
  class << self
    # Decompresses a LZW compressed string.
    #
    #
    # source://pdf-reader//lib/pdf/reader/lzw.rb#101
    sig { params(data: ::String).returns(::String) }
    def decode(data); end

    private

    # @raise [MalformedPDFError]
    #
    # source://pdf-reader//lib/pdf/reader/lzw.rb#139
    sig do
      params(
        string_table: ::PDF::Reader::LZW::StringTable,
        some_code: T.nilable(::Integer),
        other_code: T.nilable(::Integer)
      ).returns(::String)
    end
    def create_new_string(string_table, some_code, other_code); end
  end
end

# Wraps an LZW encoded string
#
# source://pdf-reader//lib/pdf/reader/lzw.rb#23
class PDF::Reader::LZW::BitStream
  # source://pdf-reader//lib/pdf/reader/lzw.rb#26
  sig { params(data: ::String, bits_in_chunk: ::Integer).void }
  def initialize(data, bits_in_chunk); end

  # source://pdf-reader//lib/pdf/reader/lzw.rb#43
  sig { returns(::Integer) }
  def read; end

  # @raise [MalformedPDFError]
  #
  # source://pdf-reader//lib/pdf/reader/lzw.rb#36
  sig { params(bits_in_chunk: ::Integer).void }
  def set_bits_in_chunk(bits_in_chunk); end
end

# source://pdf-reader//lib/pdf/reader/lzw.rb#67
PDF::Reader::LZW::CODE_CLEAR_TABLE = T.let(T.unsafe(nil), Integer)

# source://pdf-reader//lib/pdf/reader/lzw.rb#66
PDF::Reader::LZW::CODE_EOD = T.let(T.unsafe(nil), Integer)

# stores de pairs code => string
#
# source://pdf-reader//lib/pdf/reader/lzw.rb#70
class PDF::Reader::LZW::StringTable
  # source://pdf-reader//lib/pdf/reader/lzw.rb#75
  sig { void }
  def initialize; end

  # if code less than 258 return fixed string
  #
  # source://pdf-reader//lib/pdf/reader/lzw.rb#83
  sig { params(key: ::Integer).returns(T.nilable(::String)) }
  def [](key); end

  # source://pdf-reader//lib/pdf/reader/lzw.rb#92
  sig { params(string: ::String).void }
  def add(string); end

  # source://pdf-reader//lib/pdf/reader/lzw.rb#72
  sig { returns(::Integer) }
  def string_table_pos; end
end

# an exception that is raised when we believe the current PDF is not following
# the PDF spec and cannot be recovered
#
# source://pdf-reader//lib/pdf/reader/error.rb#72
class PDF::Reader::MalformedPDFError < ::RuntimeError; end

# There's no point rendering zero-width characters
#
# source://pdf-reader//lib/pdf/reader/no_text_filter.rb#7
class PDF::Reader::NoTextFilter
  class << self
    # source://pdf-reader//lib/pdf/reader/no_text_filter.rb#10
    sig { params(runs: T::Array[::PDF::Reader::TextRun]).returns(T::Array[::PDF::Reader::TextRun]) }
    def exclude_empty_strings(runs); end
  end
end

# A null object security handler. Used when a PDF is unencrypted.
#
# source://pdf-reader//lib/pdf/reader/null_security_handler.rb#8
class PDF::Reader::NullSecurityHandler
  # source://pdf-reader//lib/pdf/reader/null_security_handler.rb#11
  sig { params(buf: ::String, _ref: ::PDF::Reader::Reference).returns(::String) }
  def decrypt(buf, _ref); end
end

# A Hash-like object for caching commonly used objects from a PDF file.
#
# This is an internal class, no promises about a stable API.
#
# source://pdf-reader//lib/pdf/reader/object_cache.rb#13
class PDF::Reader::ObjectCache
  # source://pdf-reader//lib/pdf/reader/object_cache.rb#27
  sig { params(lru_size: T.untyped).void }
  def initialize(lru_size = T.unsafe(nil)); end

  # source://pdf-reader//lib/pdf/reader/object_cache.rb#34
  def [](key); end

  # source://pdf-reader//lib/pdf/reader/object_cache.rb#39
  def []=(key, value); end

  # source://pdf-reader//lib/pdf/reader/object_cache.rb#52
  def each(&block); end

  # source://pdf-reader//lib/pdf/reader/object_cache.rb#58
  def each_key(&block); end

  # source://pdf-reader//lib/pdf/reader/object_cache.rb#56
  def each_pair(&block); end

  # source://pdf-reader//lib/pdf/reader/object_cache.rb#63
  def each_value(&block); end

  # @return [Boolean]
  #
  # source://pdf-reader//lib/pdf/reader/object_cache.rb#73
  def empty?; end

  # source://pdf-reader//lib/pdf/reader/object_cache.rb#47
  def fetch(key, local_default = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://pdf-reader//lib/pdf/reader/object_cache.rb#80
  def has_key?(key); end

  # @return [Boolean]
  #
  # source://pdf-reader//lib/pdf/reader/object_cache.rb#84
  def has_value?(value); end

  # source://pdf-reader//lib/pdf/reader/object_cache.rb#21
  sig { returns(T.untyped) }
  def hits; end

  # @return [Boolean]
  #
  # source://pdf-reader//lib/pdf/reader/object_cache.rb#77
  def include?(key); end

  # @return [Boolean]
  #
  # source://pdf-reader//lib/pdf/reader/object_cache.rb#81
  def key?(key); end

  # source://pdf-reader//lib/pdf/reader/object_cache.rb#92
  def keys; end

  # source://pdf-reader//lib/pdf/reader/object_cache.rb#71
  def length; end

  # @return [Boolean]
  #
  # source://pdf-reader//lib/pdf/reader/object_cache.rb#82
  def member?(key); end

  # source://pdf-reader//lib/pdf/reader/object_cache.rb#24
  sig { returns(T.untyped) }
  def misses; end

  # source://pdf-reader//lib/pdf/reader/object_cache.rb#68
  def size; end

  # source://pdf-reader//lib/pdf/reader/object_cache.rb#88
  def to_s; end

  # source://pdf-reader//lib/pdf/reader/object_cache.rb#96
  def values; end

  private

  # @return [Boolean]
  #
  # source://pdf-reader//lib/pdf/reader/object_cache.rb#110
  def cacheable?(obj); end

  # source://pdf-reader//lib/pdf/reader/object_cache.rb#102
  def update_stats(key); end
end

# These object types use little memory and are accessed a heap of times as
# part of random page access, so we'll cache the unmarshalled objects and
# avoid lots of repetitive (and expensive) tokenising
#
# source://pdf-reader//lib/pdf/reader/object_cache.rb#18
PDF::Reader::ObjectCache::CACHEABLE_TYPES = T.let(T.unsafe(nil), Array)

# Provides low level access to the objects in a PDF file via a hash-like
# object.
#
# A PDF file can be viewed as a large hash map. It is a series of objects
# stored at precise byte offsets, and a table that maps object IDs to byte
# offsets. Given an object ID, looking up an object is an O(1) operation.
#
# Each PDF object can be mapped to a ruby object, so by passing an object
# ID to the [] method, a ruby representation of that object will be
# retrieved.
#
# The class behaves much like a standard Ruby hash, including the use of
# the Enumerable mixin. The key difference is no []= method - the hash
# is read only.
#
# == Basic Usage
#
#     h = PDF::Reader::ObjectHash.new("somefile.pdf")
#     h[1]
#     => 3469
#
#     h[PDF::Reader::Reference.new(1,0)]
#     => 3469
#
# source://pdf-reader//lib/pdf/reader/object_hash.rb#32
class PDF::Reader::ObjectHash
  include ::Enumerable

  # Creates a new ObjectHash object. Input can be a string with a valid filename
  # or an IO-like object.
  #
  # Valid options:
  #
  #   :password - the user password to decrypt the source PDF
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#63
  sig { params(input: T.any(::IO, ::String, ::StringIO, ::Tempfile), opts: T::Hash[::Symbol, T.untyped]).void }
  def initialize(input, opts = T.unsafe(nil)); end

  # Access an object from the PDF. key can be an int or a PDF::Reader::Reference
  # object.
  #
  # If an int is used, the object with that ID and a generation number of 0 will
  # be returned.
  #
  # If a PDF::Reader::Reference object is used the exact ID and generation number
  # can be specified.
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#103
  sig { params(key: T.any(::Integer, ::PDF::Reader::Reference)).returns(T.untyped) }
  def [](key); end

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#44
  sig { returns(T.untyped) }
  def default; end

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#44
  def default=(_arg0); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#122
  def deref(*args, **_arg1, &blk); end

  # Recursively dereferences the object refered to be +key+. If +key+ is not
  # a PDF::Reader::Reference, the key is returned unchanged.
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#350
  sig { params(key: T.untyped).returns(T.untyped) }
  def deref!(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return an Array or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting an Array and no other type will do.
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#131
  sig { params(key: T.untyped).returns(T.nilable(T::Array[T.untyped])) }
  def deref_array(key); end

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#355
  sig { params(key: T.untyped).returns(T.nilable(T::Array[T.untyped])) }
  def deref_array!(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return an Array of Numerics or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting an Array and no other type will do.
  #
  # Some effort to cast array elements to a number is made for any non-numeric elements.
  #
  # @raise [MalformedPDFError]
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#150
  sig { params(key: T.untyped).returns(T.nilable(T::Array[::Numeric])) }
  def deref_array_of_numbers(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return a Hash or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting an Array and no other type will do.
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#177
  sig { params(key: T.untyped).returns(T.nilable(T::Hash[::Symbol, T.untyped])) }
  def deref_hash(key); end

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#364
  sig { params(key: T.untyped).returns(T.nilable(T::Hash[::Symbol, T.untyped])) }
  def deref_hash!(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return an Integer or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting an Array and no other type will do.
  #
  # Some effort to cast to an int is made when the reference points to a non-integer.
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#221
  sig { params(key: T.untyped).returns(T.nilable(::Integer)) }
  def deref_integer(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return a PDF name (Symbol) or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting an Array and no other type will do.
  #
  # Some effort to cast to a symbol is made when the reference points to a non-symbol.
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#196
  sig { params(key: T.untyped).returns(T.nilable(::Symbol)) }
  def deref_name(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return a PDF Name (symbol), Array or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting a Name or Array and no other type will do.
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#315
  sig { params(key: T.untyped).returns(T.nilable(T.any(::Symbol, T::Array[T.untyped]))) }
  def deref_name_or_array(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return a Numeric or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting an Array and no other type will do.
  #
  # Some effort to cast to a number is made when the reference points to a non-number.
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#246
  sig { params(key: T.untyped).returns(T.nilable(::Numeric)) }
  def deref_number(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return a PDF::Reader::Stream or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting a stream and no other type will do.
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#271
  sig { params(key: T.untyped).returns(T.nilable(::PDF::Reader::Stream)) }
  def deref_stream(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return a PDF::Reader::Stream, Array or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting a stream or Array and no other type will do.
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#334
  sig { params(key: T.untyped).returns(T.nilable(T.any(::PDF::Reader::Stream, T::Array[T.untyped]))) }
  def deref_stream_or_array(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return a String or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting a string and no other type will do.
  #
  # Some effort to cast to a string is made when the reference points to a non-string.
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#292
  sig { params(key: T.untyped).returns(T.nilable(::String)) }
  def deref_string(key); end

  # iterate over each key, value. Just like a ruby hash.
  #
  # @override(allow_incompatible: true)
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#400
  sig do
    override
      .params(
        block: T.proc.params(arg0: ::PDF::Reader::Reference, arg1: T.untyped).returns(T.untyped)
      ).returns(T.untyped)
  end
  def each(&block); end

  # iterate over each key. Just like a ruby hash.
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#410
  sig { params(block: T.proc.params(arg0: ::PDF::Reader::Reference).returns(T.untyped)).returns(T.untyped) }
  def each_key(&block); end

  # iterate over each key, value. Just like a ruby hash.
  #
  # @override(allow_incompatible: true)
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#405
  def each_pair(*args, **_arg1, &blk); end

  # iterate over each value. Just like a ruby hash.
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#419
  sig { params(block: T.proc.params(arg0: T.untyped).returns(T.untyped)).returns(T.untyped) }
  def each_value(&block); end

  # return true if there are no objects in this file
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#436
  sig { returns(T::Boolean) }
  def empty?; end

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#528
  sig { returns(T::Boolean) }
  def encrypted?; end

  # Access an object from the PDF. key can be an int or a PDF::Reader::Reference
  # object.
  #
  # If an int is used, the object with that ID and a generation number of 0 will
  # be returned.
  #
  # If a PDF::Reader::Reference object is used the exact ID and generation number
  # can be specified.
  #
  # local_default is the object that will be returned if the requested key doesn't
  # exist.
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#385
  sig { params(key: T.untyped, local_default: T.untyped).returns(T.untyped) }
  def fetch(key, local_default = T.unsafe(nil)); end

  # return true if the specified key exists in the file. key
  # can be an int or a PDF::Reader::Reference
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#444
  sig { params(check_key: T.untyped).returns(T::Boolean) }
  def has_key?(check_key); end

  # return true if the specifiedvalue exists in the file
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#462
  sig { params(value: T.untyped).returns(T::Boolean) }
  def has_value?(value); end

  # return true if the specified key exists in the file. key
  # can be an int or a PDF::Reader::Reference
  #
  #
  # @return [Boolean]
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#455
  def include?(*args, **_arg1, &blk); end

  # return true if the specified key exists in the file. key
  # can be an int or a PDF::Reader::Reference
  #
  #
  # @return [Boolean]
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#456
  def key?(*args, **_arg1, &blk); end

  # return an array of all keys in the file
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#479
  sig { returns(T::Array[::PDF::Reader::Reference]) }
  def keys; end

  # return the number of objects in the file. An object with multiple generations
  # is counted once.
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#431
  def length(*args, **_arg1, &blk); end

  # return true if the specified key exists in the file. key
  # can be an int or a PDF::Reader::Reference
  #
  #
  # @return [Boolean]
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#457
  def member?(*args, **_arg1, &blk); end

  # returns the type of object a ref points to
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#81
  sig { params(ref: T.any(::Integer, ::PDF::Reader::Reference)).returns(T.nilable(::Symbol)) }
  def obj_type(ref); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#119
  sig { params(key: T.untyped).returns(T.untyped) }
  def object(key); end

  # returns an array of PDF::Reader::References. Each reference in the
  # array points a Page object, one for each page in the PDF. The first
  # reference is page 1, second reference is page 2, etc.
  #
  # Useful for apps that want to extract data from specific pages.
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#519
  sig { returns(T::Array[T.any(::PDF::Reader::Reference, T::Hash[::Symbol, T.untyped])]) }
  def page_references; end

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#50
  sig { returns(::Float) }
  def pdf_version; end

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#53
  sig { returns(T.untyped) }
  def sec_handler; end

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#533
  sig { returns(T::Boolean) }
  def sec_handler?; end

  # return the number of objects in the file. An object with multiple generations
  # is counted once.
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#428
  sig { returns(::Integer) }
  def size; end

  # returns true if the supplied references points to an object with a stream
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#89
  sig { params(ref: T.any(::Integer, ::PDF::Reader::Reference)).returns(T::Boolean) }
  def stream?(ref); end

  # return an array of arrays. Each sub array contains a key/value pair.
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#504
  sig { returns(T.untyped) }
  def to_a; end

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#472
  sig { returns(::String) }
  def to_s; end

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#47
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def trailer; end

  # return true if the specified key exists in the file. key
  # can be an int or a PDF::Reader::Reference
  #
  #
  # @return [Boolean]
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#469
  def value?(*args, **_arg1, &blk); end

  # return an array of all values in the file
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#488
  sig { returns(T.untyped) }
  def values; end

  # return an array of all values from the specified keys
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#497
  sig { params(ids: T.untyped).returns(T.untyped) }
  def values_at(*ids); end

  private

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#599
  sig do
    params(
      ref: ::PDF::Reader::Reference,
      obj: T.untyped
    ).returns(T.nilable(T.any(::Numeric, ::PDF::Reader::Reference, ::PDF::Reader::Stream, ::PDF::Reader::Token, ::String, ::Symbol, T::Array[T.untyped], T::Hash[T.untyped, T.untyped])))
  end
  def decrypt(ref, obj); end

  # Private implementation of deref!, which exists to ensure the `seen` argument
  # isn't publicly available. It's used to avoid endless loops in the recursion, and
  # doesn't need to be part of the public API.
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#569
  sig do
    params(
      key: T.untyped,
      seen: T::Hash[::Integer, T.untyped]
    ).returns(T.nilable(T.any(::Numeric, ::PDF::Reader::Reference, ::PDF::Reader::Stream, ::PDF::Reader::Token, ::String, ::Symbol, T::Array[T.untyped], T::Hash[T.untyped, T.untyped])))
  end
  def deref_internal!(key, seen); end

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#665
  sig { params(input: T.any(::IO, ::String, ::StringIO, ::Tempfile)).returns(T.any(::IO, ::StringIO, ::Tempfile)) }
  def extract_io_from(input); end

  # parse a traditional object from the PDF, starting from the byte offset indicated
  # in the xref table
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#543
  sig do
    params(
      key: ::PDF::Reader::Reference
    ).returns(T.nilable(T.any(::Numeric, ::PDF::Reader::Reference, ::PDF::Reader::Stream, ::PDF::Reader::Token, ::String, ::Symbol, T::Array[T.untyped], T::Hash[T.untyped, T.untyped])))
  end
  def fetch_object(key); end

  # parse a object that's embedded in an object stream in the PDF
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#553
  sig do
    params(
      key: ::PDF::Reader::Reference
    ).returns(T.nilable(T.any(::Numeric, ::PDF::Reader::Reference, ::PDF::Reader::Stream, ::PDF::Reader::Token, ::String, ::Symbol, T::Array[T.untyped], T::Hash[T.untyped, T.untyped])))
  end
  def fetch_object_stream(key); end

  # returns an array of object references for all pages in this object store. The ordering of
  # the Array is significant and matches the page ordering of the document
  #
  #
  # source://pdf-reader//lib/pdf/reader/object_hash.rb#639
  sig do
    params(
      obj: T.any(::PDF::Reader::Reference, T::Hash[::Symbol, T.untyped])
    ).returns(T::Array[T.any(::PDF::Reader::Reference, T::Hash[::Symbol, T.untyped])])
  end
  def get_page_objects(obj); end

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#621
  sig { params(offset: ::Integer).returns(::PDF::Reader::Buffer) }
  def new_buffer(offset = T.unsafe(nil)); end

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#631
  sig { returns(T::Hash[::PDF::Reader::Reference, ::PDF::Reader::ObjectStream]) }
  def object_streams; end

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#676
  sig { params(input: ::String).returns(::String) }
  def read_as_binary(input); end

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#657
  sig { returns(::Float) }
  def read_version; end

  # source://pdf-reader//lib/pdf/reader/object_hash.rb#626
  sig { returns(PDF::Reader::XRef[::PDF::Reader::Reference]) }
  def xref; end
end

# provides a wrapper around a PDF stream object that contains other objects in it.
# This is done for added compression and is described as an "Object Stream" in the spec.
#
# source://pdf-reader//lib/pdf/reader/object_stream.rb#10
class PDF::Reader::ObjectStream
  # source://pdf-reader//lib/pdf/reader/object_stream.rb#12
  sig { params(stream: ::PDF::Reader::Stream).void }
  def initialize(stream); end

  # source://pdf-reader//lib/pdf/reader/object_stream.rb#20
  sig do
    params(
      objid: ::Integer
    ).returns(T.nilable(T.any(::Numeric, ::PDF::Reader::Reference, ::PDF::Reader::Token, ::String, ::Symbol, T::Array[T.untyped], T::Hash[T.untyped, T.untyped])))
  end
  def [](objid); end

  # source://pdf-reader//lib/pdf/reader/object_stream.rb#31
  sig { returns(::Integer) }
  def size; end

  private

  # source://pdf-reader//lib/pdf/reader/object_stream.rb#54
  sig { returns(::PDF::Reader::Buffer) }
  def buffer; end

  # source://pdf-reader//lib/pdf/reader/object_stream.rb#49
  sig { returns(::Integer) }
  def first; end

  # source://pdf-reader//lib/pdf/reader/object_stream.rb#38
  sig { returns(T::Hash[::Integer, ::Integer]) }
  def offsets; end
end

# remove duplicates from a collection of TextRun objects. This can be helpful when a PDF
# uses slightly offset overlapping characters to achieve a fake 'bold' effect.
#
# source://pdf-reader//lib/pdf/reader/overlapping_runs_filter.rb#8
class PDF::Reader::OverlappingRunsFilter
  class << self
    # source://pdf-reader//lib/pdf/reader/overlapping_runs_filter.rb#43
    sig do
      params(
        sweep_line_status: T::Array[::PDF::Reader::TextRun],
        event_point: ::PDF::Reader::EventPoint
      ).returns(T::Boolean)
    end
    def detect_intersection(sweep_line_status, event_point); end

    # source://pdf-reader//lib/pdf/reader/overlapping_runs_filter.rb#15
    sig { params(runs: T::Array[::PDF::Reader::TextRun]).returns(T::Array[::PDF::Reader::TextRun]) }
    def exclude_redundant_runs(runs); end
  end
end

# This should be between 0 and 1. If TextRun B obscures this much of TextRun A (and they
# have identical characters) then one will be discarded
#
# source://pdf-reader//lib/pdf/reader/overlapping_runs_filter.rb#12
PDF::Reader::OverlappingRunsFilter::OVERLAPPING_THRESHOLD = T.let(T.unsafe(nil), Float)

# high level representation of a single PDF page. Ties together the various
# low level classes in PDF::Reader and provides access to the various
# components of the page (text, images, fonts, etc) in convenient formats.
#
# If you require access to the raw PDF objects for this page, you can access
# the Page dictionary via the page_object accessor. You will need to use the
# objects accessor to help walk the page dictionary in any useful way.
#
# source://pdf-reader//lib/pdf/reader/page.rb#18
class PDF::Reader::Page
  extend ::Forwardable

  # creates a new page wrapper.
  #
  # * objects - an ObjectHash instance that wraps a PDF file
  # * pagenum - an int specifying the page number to expose. 1 indexed.
  #
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#50
  sig { params(objects: ::PDF::Reader::ObjectHash, pagenum: ::Integer, options: T::Hash[::Symbol, T.untyped]).void }
  def initialize(objects, pagenum, options = T.unsafe(nil)); end

  # Returns the attributes that accompany this page, including
  # attributes inherited from parents.
  #
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#83
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def attributes; end

  # returns the "boxes" that define the page object.
  # values are defaulted according to section 7.7.3.3 of the PDF Spec 1.7
  #
  # DEPRECATED. Recommend using Page#rectangles instead
  #
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#215
  sig { returns(T::Hash[::Symbol, T::Array[::Numeric]]) }
  def boxes; end

  # a Hash-like object for storing cached data. Generally this is scoped to
  # the current document and is used to avoid repeating expensive
  # operations
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#33
  sig { returns(T.any(::PDF::Reader::ObjectCache, T::Hash[T.untyped, T.untyped])) }
  def cache; end

  # source://pdf-reader//lib/pdf/reader/page.rb#35
  def color_spaces(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page.rb#36
  def fonts(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page.rb#37
  def graphic_states(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page.rb#96
  sig { returns(::Numeric) }
  def height; end

  # return a friendly string representation of this page
  #
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#75
  sig { returns(::String) }
  def inspect; end

  # return the number of this page within the full document
  #
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#68
  sig { returns(::Integer) }
  def number; end

  # lowlevel hash-like access to all objects in the underlying PDF
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#23
  sig { returns(::PDF::Reader::ObjectHash) }
  def objects; end

  # Convenience method to identify the page's orientation.
  #
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#120
  sig { returns(::String) }
  def orientation; end

  # source://pdf-reader//lib/pdf/reader/page.rb#110
  sig { returns(T::Array[::Numeric]) }
  def origin; end

  # the raw PDF object that defines this page
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#27
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def page_object; end

  # source://pdf-reader//lib/pdf/reader/page.rb#38
  def patterns(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page.rb#39
  def procedure_sets(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page.rb#40
  def properties(*args, **_arg1, &block); end

  # returns the raw content stream for this page. This is plumbing, nothing to
  # see here unless you're a PDF nerd like me.
  #
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#187
  sig { returns(::String) }
  def raw_content; end

  # returns the "boxes" that define the page object.
  # values are defaulted according to section 7.7.3.3 of the PDF Spec 1.7
  #
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#224
  sig { returns(T::Hash[::Symbol, ::PDF::Reader::Rectangle]) }
  def rectangles; end

  # returns the angle to rotate the page clockwise. Always 0, 90, 180 or 270
  #
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#199
  sig { returns(::Integer) }
  def rotate; end

  # source://pdf-reader//lib/pdf/reader/page.rb#145
  sig { params(opts: T::Hash[::Symbol, T.untyped]).returns(T::Array[::PDF::Reader::TextRun]) }
  def runs(opts = T.unsafe(nil)); end

  # source://pdf-reader//lib/pdf/reader/page.rb#41
  def shadings(*args, **_arg1, &block); end

  # returns the plain text content of this page encoded as UTF-8. Any
  # characters that can't be translated will be returned as a ▯
  #
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#132
  sig { params(opts: T::Hash[::Symbol, T.untyped]).returns(::String) }
  def text(opts = T.unsafe(nil)); end

  # returns the plain text content of this page encoded as UTF-8. Any
  # characters that can't be translated will be returned as a ▯
  #
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#142
  def to_s(*args, **_arg1, &blk); end

  # processes the raw content stream for this page in sequential order and
  # passes callbacks to the receiver objects.
  #
  # This is mostly low level and you can probably ignore it unless you need
  # access to something like the raw encoded text. For an example of how
  # this can be used as a basis for higher level functionality, see the
  # text() method
  #
  # If someone was motivated enough, this method is intended to provide all
  # the data required to faithfully render the entire page. If you find
  # some required data isn't available it's a bug - let me know.
  #
  # Many operators that generate callbacks will reference resources stored
  # in the page header - think images, fonts, etc. To facilitate these
  # operators, the first available callback is page=. If your receiver
  # accepts that callback it will be passed the current
  # PDF::Reader::Page object. Use the Page#resources method to grab any
  # required resources.
  #
  # It may help to think of each page as a self contained program made up of
  # a set of instructions and associated resources. Calling walk() executes
  # the program in the correct order and calls out to your implementation.
  #
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#175
  sig { params(receivers: T.untyped).returns(T.untyped) }
  def walk(*receivers); end

  # source://pdf-reader//lib/pdf/reader/page.rb#103
  sig { returns(::Numeric) }
  def width; end

  # source://pdf-reader//lib/pdf/reader/page.rb#42
  def xobjects(*args, **_arg1, &block); end

  private

  # source://pdf-reader//lib/pdf/reader/page.rb#324
  sig { params(origin: T.untyped, seen: T::Set[::Integer]).returns(T.untyped) }
  def ancestors(origin = T.unsafe(nil), seen = T.unsafe(nil)); end

  # calls the name callback method on each receiver object with params as the arguments
  #
  # The silly style here is because sorbet won't let me use splat arguments
  #
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#297
  sig { params(receivers: T::Array[::Object], name: ::Symbol, params: T::Array[T.untyped]).void }
  def callback(receivers, name, params = T.unsafe(nil)); end

  # source://pdf-reader//lib/pdf/reader/page.rb#275
  sig { params(receivers: T::Array[T.untyped], instructions: ::String).void }
  def content_stream(receivers, instructions); end

  # source://pdf-reader//lib/pdf/reader/page.rb#319
  sig { returns(T.untyped) }
  def page_with_ancestors; end

  # Returns the resources that accompany this page. Includes
  # resources inherited from parents.
  #
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#270
  sig { returns(::PDF::Reader::Resources) }
  def resources; end

  # source://pdf-reader//lib/pdf/reader/page.rb#262
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def root; end

  # select the elements from a Pages dictionary that can be inherited by
  # child Page dictionaries.
  #
  #
  # source://pdf-reader//lib/pdf/reader/page.rb#342
  sig { params(obj: T::Hash[::Symbol, T.untyped]).returns(T::Hash[::Symbol, T.untyped]) }
  def select_inheritable(obj); end
end

# Takes a collection of TextRun objects and renders them into a single
# string that best approximates the way they'd appear on a render PDF page.
#
# media box should be a 4 number array that describes the dimensions of the
# page to be rendered as described by the page's MediaBox attribute
#
# source://pdf-reader//lib/pdf/reader/page_layout.rb#15
class PDF::Reader::PageLayout
  # source://pdf-reader//lib/pdf/reader/page_layout.rb#20
  sig do
    params(
      runs: T::Array[::PDF::Reader::TextRun],
      mediabox: T.any(::PDF::Reader::Rectangle, T::Array[::Numeric])
    ).void
  end
  def initialize(runs, mediabox); end

  # source://pdf-reader//lib/pdf/reader/page_layout.rb#40
  sig { returns(::String) }
  def to_s; end

  private

  # source://pdf-reader//lib/pdf/reader/page_layout.rb#91
  sig { returns(T.untyped) }
  def col_count; end

  # source://pdf-reader//lib/pdf/reader/page_layout.rb#101
  sig { returns(T.untyped) }
  def col_multiplier; end

  # given an array of strings, return a new array with empty rows from the
  # beginning and end removed.
  #
  #   interesting_rows([ "", "one", "two", "" ])
  #   => [ "one", "two" ]
  #
  #
  # source://pdf-reader//lib/pdf/reader/page_layout.rb#74
  sig { params(rows: T.untyped).returns(T.untyped) }
  def interesting_rows(rows); end

  # source://pdf-reader//lib/pdf/reader/page_layout.rb#124
  sig { params(haystack: T.untyped, needle: T.untyped, index: T.untyped).returns(T.untyped) }
  def local_string_insert(haystack, needle, index); end

  # source://pdf-reader//lib/pdf/reader/page_layout.rb#106
  sig { params(collection: T.untyped).returns(T.untyped) }
  def mean(collection); end

  # source://pdf-reader//lib/pdf/reader/page_layout.rb#115
  sig { params(collection: T.untyped).returns(T.untyped) }
  def median(collection); end

  # source://pdf-reader//lib/pdf/reader/page_layout.rb#63
  sig { returns(::Numeric) }
  def page_height; end

  # source://pdf-reader//lib/pdf/reader/page_layout.rb#58
  sig { returns(::Numeric) }
  def page_width; end

  # source://pdf-reader//lib/pdf/reader/page_layout.rb#129
  sig { params(mediabox: T.untyped).returns(T.untyped) }
  def process_mediabox(mediabox); end

  # source://pdf-reader//lib/pdf/reader/page_layout.rb#86
  sig { returns(T.untyped) }
  def row_count; end

  # source://pdf-reader//lib/pdf/reader/page_layout.rb#96
  sig { returns(T.untyped) }
  def row_multiplier; end
end

# source://pdf-reader//lib/pdf/reader/page_layout.rb#17
PDF::Reader::PageLayout::DEFAULT_FONT_SIZE = T.let(T.unsafe(nil), Integer)

# encapsulates logic for tracking graphics state as the instructions for
# a single page are processed. Most of the public methods correspond
# directly to PDF operators.
#
# source://pdf-reader//lib/pdf/reader/page_state.rb#11
class PDF::Reader::PageState
  # starting a new page
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#27
  sig { params(page: T.untyped).void }
  def initialize(page); end

  # Text Object Operators
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#93
  def begin_text_object; end

  # This returns a deep clone of the current state, ensuring changes are
  # keep separate from earlier states.
  #
  # Marshal is used to round-trip the state through a string to easily
  # perform the deep clone. Kinda hacky, but effective.
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#294
  def clone_state; end

  # update the current transformation matrix.
  #
  # If the CTM is currently undefined, just store the new values.
  #
  # If there's an existing CTM, then multiply the existing matrix
  # with the new matrix to form the updated matrix.
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#75
  def concatenate_matrix(a, b, c, d, e, f); end

  # transform x and y co-ordinates from the current user space to the
  # underlying device space.
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#230
  def ctm_transform(x, y); end

  # source://pdf-reader//lib/pdf/reader/page_state.rb#255
  def current_font; end

  # source://pdf-reader//lib/pdf/reader/page_state.rb#99
  def end_text_object; end

  # source://pdf-reader//lib/pdf/reader/page_state.rb#266
  def find_color_space(label); end

  # source://pdf-reader//lib/pdf/reader/page_state.rb#259
  def find_font(label); end

  # source://pdf-reader//lib/pdf/reader/page_state.rb#273
  def find_xobject(label); end

  # source://pdf-reader//lib/pdf/reader/page_state.rb#120
  def font_size; end

  # XObjects
  #
  # @raise [MalformedPDFError]
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#201
  def invoke_xobject(label); end

  # Text Positioning Operators
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#148
  def move_text_position(x, y); end

  # TD
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#161
  def move_text_position_and_set_leading(x, y); end

  # '
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#188
  def move_to_next_line_and_show_text(str); end

  # T*
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#176
  def move_to_start_of_next_line; end

  # after each glyph is painted onto the page the text matrix must be
  # modified. There's no defined operator for this, but depending on
  # the use case some receivers may need to mutate the state with this
  # while walking a page.
  #
  # NOTE: some of the variable names in this method are obscure because
  #       they mirror variable names from the PDF spec
  #
  # NOTE: see Section 9.4.4, PDF 32000-1:2008, pp 252
  #
  # Arguments:
  #
  # w0 - the glyph width in *text space*. This generally means the width
  #      in glyph space should be divded by 1000 before being passed to
  #      this function
  # tj - any kerning that should be applied to the text matrix before the
  #      following glyph is painted. This is usually the numeric arguments
  #      in the array passed to a TJ operator
  # word_boundary - a boolean indicating if a word boundary was just
  #                 reached. Depending on the current state extra space
  #                 may need to be added
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#324
  def process_glyph_displacement(w0, tj, word_boundary); end

  # Restore the state to the previous value on the stack.
  #
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#60
  sig { returns(T.untyped) }
  def restore_graphics_state; end

  # Clones the current graphics state and push it onto the top of the stack.
  # Any changes that are subsequently made to the state can then by reversed
  # by calling restore_graphics_state.
  #
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#53
  sig { returns(T.untyped) }
  def save_graphics_state; end

  # Text State Operators
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#107
  def set_character_spacing(char_spacing); end

  # source://pdf-reader//lib/pdf/reader/page_state.rb#111
  def set_horizontal_text_scaling(h_scaling); end

  # "
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#192
  def set_spacing_next_line_show_text(aw, ac, string); end

  # source://pdf-reader//lib/pdf/reader/page_state.rb#115
  def set_text_font_and_size(label, size); end

  # source://pdf-reader//lib/pdf/reader/page_state.rb#128
  def set_text_leading(leading); end

  # Tm
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#166
  def set_text_matrix_and_text_line_matrix(a, b, c, d, e, f); end

  # source://pdf-reader//lib/pdf/reader/page_state.rb#132
  def set_text_rendering_mode(mode); end

  # source://pdf-reader//lib/pdf/reader/page_state.rb#136
  def set_text_rise(rise); end

  # source://pdf-reader//lib/pdf/reader/page_state.rb#140
  def set_word_spacing(word_spacing); end

  # Text Showing Operators
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#184
  def show_text_with_positioning(params); end

  # when save_graphics_state is called, we need to push a new copy of the
  # current state onto the stack. That way any modifications to the state
  # will be undone once restore_graphics_state is called.
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#284
  def stack_depth; end

  # transform x and y co-ordinates from the current text space to the
  # underlying device space.
  #
  # transforming (0,0) is a really common case, so optimise for it to
  # avoid unnecessary object allocations
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#243
  def trm_transform(x, y); end

  private

  # wrap the raw PDF Font objects in handy ruby Font objects.
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#394
  def build_fonts(raw_fonts); end

  # return the current transformation matrix
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#384
  def ctm; end

  # This class uses 3x3 matrices to represent geometric transformations
  # These matrices are represented by arrays with 9 elements
  # The array [a,b,c,d,e,f,g,h,i] would represent a matrix like:
  #   a b c
  #   d e f
  #   g h i
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#413
  def identity_matrix; end

  # source://pdf-reader//lib/pdf/reader/page_state.rb#388
  def state; end

  # used for many and varied text positioning calculations. We potentially
  # need to access the results of this method many times when working with
  # text, so memoize it
  #
  # source://pdf-reader//lib/pdf/reader/page_state.rb#362
  def text_rendering_matrix; end
end

# source://pdf-reader//lib/pdf/reader/page_state.rb#13
PDF::Reader::PageState::DEFAULT_GRAPHICS_STATE = T.let(T.unsafe(nil), Hash)

# Builds a UTF-8 string of all the text on a single page by processing all
# the operaters in a content stream.
#
# source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#14
class PDF::Reader::PageTextReceiver
  extend ::Forwardable

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#33
  def begin_text_object(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#30
  def concatenate_matrix(*args, **_arg1, &block); end

  # deprecated
  #
  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#87
  def content; end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#33
  def end_text_object(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#37
  def font_size(*args, **_arg1, &block); end

  # XObjects
  #
  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#126
  def invoke_xobject(label); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#42
  def move_text_position(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#42
  def move_text_position_and_set_leading(*args, **_arg1, &block); end

  # '
  #
  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#112
  def move_to_next_line_and_show_text(str); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#43
  def move_to_start_of_next_line(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#23
  sig { returns(T.untyped) }
  def options; end

  # starting a new page
  #
  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#47
  def page=(page); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#27
  def restore_graphics_state(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#54
  def runs(opts = T.unsafe(nil)); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#27
  def save_graphics_state(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#36
  def set_character_spacing(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#36
  def set_horizontal_text_scaling(*args, **_arg1, &block); end

  # "
  #
  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#117
  def set_spacing_next_line_show_text(aw, ac, string); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#37
  def set_text_font_and_size(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#38
  def set_text_leading(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#43
  def set_text_matrix_and_text_line_matrix(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#38
  def set_text_rendering_mode(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#39
  def set_text_rise(*args, **_arg1, &block); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#39
  def set_word_spacing(*args, **_arg1, &block); end

  # Text Showing Operators
  #
  # record text that is drawn on the page
  #
  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#96
  def show_text(string); end

  # TJ [(A) 120 (WA) 20 (Y)]
  #
  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#100
  def show_text_with_positioning(params); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#20
  sig { returns(T.untyped) }
  def state; end

  private

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#162
  def apply_rotation(x, y); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#188
  def group_chars_into_runs(chars); end

  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#137
  def internal_show_text(string); end

  # take a collection of TextRun objects and merge any that are in close
  # proximity
  #
  # source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#180
  def merge_runs(runs); end
end

# source://pdf-reader//lib/pdf/reader/page_text_receiver.rb#17
PDF::Reader::PageTextReceiver::SPACE = T.let(T.unsafe(nil), String)

# == Text Callbacks
#
# - end_text_object
# - move_to_start_of_next_line
# - set_character_spacing
# - move_text_position
# - move_text_position_and_set_leading
# - set_text_font_and_size
# - show_text
# - show_text_with_positioning
# - set_text_leading
# - set_text_matrix_and_text_line_matrix
# - set_text_rendering_mode
# - set_text_rise
# - set_word_spacing
# - set_horizontal_text_scaling
# - move_to_next_line_and_show_text
# - set_spacing_next_line_show_text
#
# == Graphics Callbacks
# - close_fill_stroke
# - fill_stroke
# - close_fill_stroke_with_even_odd
# - fill_stroke_with_even_odd
# - begin_marked_content_with_pl
# - begin_inline_image
# - begin_marked_content
# - begin_text_object
# - append_curved_segment
# - concatenate_matrix
# - set_stroke_color_space
# - set_nonstroke_color_space
# - set_line_dash
# - set_glyph_width
# - set_glyph_width_and_bounding_box
# - invoke_xobject
# - define_marked_content_with_pl
# - end_inline_image
# - end_marked_content
# - fill_path_with_nonzero
# - fill_path_with_nonzero
# - fill_path_with_even_odd
# - set_gray_for_stroking
# - set_gray_for_nonstroking
# - set_graphics_state_parameters
# - close_subpath
# - set_flatness_tolerance
# - begin_inline_image_data
# - set_line_join_style
# - set_line_cap_style
# - set_cmyk_color_for_stroking,
# - set_cmyk_color_for_nonstroking
# - append_line
# - begin_new_subpath
# - set_miter_limit
# - define_marked_content_point
# - end_path
# - save_graphics_state
# - restore_graphics_state
# - append_rectangle
# - set_rgb_color_for_stroking
# - set_rgb_color_for_nonstroking
# - set_color_rendering_intent
# - close_and_stroke_path
# - stroke_path
# - set_color_for_stroking
# - set_color_for_nonstroking
# - set_color_for_stroking_and_special
# - set_color_for_nonstroking_and_special
# - paint_area_with_shading_pattern
# - append_curved_segment_initial_point_replicated
# - set_line_width
# - set_clipping_path_with_nonzero
# - set_clipping_path_with_even_odd
# - append_curved_segment_final_point_replicated
#
# source://pdf-reader//lib/pdf/reader/pages_strategy.rb#108
class PDF::Reader::PagesStrategy; end

# source://pdf-reader//lib/pdf/reader/pages_strategy.rb#109
PDF::Reader::PagesStrategy::OPERATORS = T.let(T.unsafe(nil), Hash)

# An internal PDF::Reader class that reads objects from the PDF file and converts
# them into useable ruby objects (hash's, arrays, true, false, etc)
#
# source://pdf-reader//lib/pdf/reader/parser.rb#34
class PDF::Reader::Parser
  # Create a new parser around a PDF::Reader::Buffer object
  #
  # buffer - a PDF::Reader::Buffer object that contains PDF data
  # objects  - a PDF::Reader::ObjectHash object that can return objects from the PDF file
  #
  # source://pdf-reader//lib/pdf/reader/parser.rb#66
  sig { params(buffer: ::PDF::Reader::Buffer, objects: T.nilable(::PDF::Reader::ObjectHash)).void }
  def initialize(buffer, objects = T.unsafe(nil)); end

  # Reads an entire PDF object from the buffer and returns it as a Ruby String.
  # If the object is a content stream, returns both the stream and the dictionary
  # that describes it
  #
  # id  - the object ID to return
  # gen - the object revision number to return
  #
  # source://pdf-reader//lib/pdf/reader/parser.rb#104
  sig do
    params(
      id: ::Integer,
      gen: ::Integer
    ).returns(T.nilable(T.any(::Numeric, ::PDF::Reader::Reference, ::PDF::Reader::Stream, ::PDF::Reader::Token, ::String, ::Symbol, T::Array[T.untyped], T::Hash[T.untyped, T.untyped])))
  end
  def object(id, gen); end

  # Reads the next token from the underlying buffer and convets it to an appropriate
  # object
  #
  # operators - a hash of supported operators to read from the underlying buffer.
  #
  # source://pdf-reader//lib/pdf/reader/parser.rb#76
  sig do
    params(
      operators: T::Hash[T.any(::PDF::Reader::Token, ::String), ::Symbol]
    ).returns(T.nilable(T.any(::Numeric, ::PDF::Reader::Reference, ::PDF::Reader::Token, ::String, ::Symbol, T::Array[T.untyped], T::Hash[T.untyped, T.untyped])))
  end
  def parse_token(operators = T.unsafe(nil)); end

  private

  # reads a PDF array from the buffer and converts it to a Ruby Array.
  #
  # source://pdf-reader//lib/pdf/reader/parser.rb#167
  sig { returns(T::Array[T.untyped]) }
  def array; end

  # reads a PDF dict from the buffer and converts it to a Ruby Hash.
  #
  # source://pdf-reader//lib/pdf/reader/parser.rb#130
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def dictionary; end

  # Reads a PDF hex string from the buffer and converts it to a Ruby String
  #
  # source://pdf-reader//lib/pdf/reader/parser.rb#182
  sig { returns(::String) }
  def hex_string; end

  # reads a PDF name from the buffer and converts it to a Ruby Symbol
  #
  # source://pdf-reader//lib/pdf/reader/parser.rb#149
  sig { returns(::Symbol) }
  def pdf_name; end

  # Decodes the contents of a PDF Stream and returns it as a Ruby String.
  #
  # @raise [MalformedPDFError]
  #
  # source://pdf-reader//lib/pdf/reader/parser.rb#235
  sig { params(dict: T::Hash[::Symbol, T.untyped]).returns(::PDF::Reader::Stream) }
  def stream(dict); end

  # Reads a PDF String from the buffer and converts it to a Ruby String
  #
  # @raise [MalformedPDFError]
  #
  # source://pdf-reader//lib/pdf/reader/parser.rb#199
  sig { returns(::String) }
  def string; end
end

# source://pdf-reader//lib/pdf/reader/parser.rb#216
PDF::Reader::Parser::MAPPING = T.let(T.unsafe(nil), Hash)

# source://pdf-reader//lib/pdf/reader/parser.rb#38
PDF::Reader::Parser::STRATEGIES = T.let(T.unsafe(nil), Hash)

# source://pdf-reader//lib/pdf/reader/parser.rb#36
PDF::Reader::Parser::TOKEN_STRATEGY = T.let(T.unsafe(nil), Proc)

# PDFs are all about positioning content on a page, so there's lots of need to
# work with a set of X,Y coordinates.
#
# source://pdf-reader//lib/pdf/reader/point.rb#11
class PDF::Reader::Point
  # source://pdf-reader//lib/pdf/reader/point.rb#20
  sig { params(x: ::Numeric, y: ::Numeric).void }
  def initialize(x, y); end

  # source://pdf-reader//lib/pdf/reader/point.rb#26
  sig { params(other: ::PDF::Reader::Point).returns(T::Boolean) }
  def ==(other); end

  # source://pdf-reader//lib/pdf/reader/point.rb#14
  sig { returns(::Numeric) }
  def x; end

  # source://pdf-reader//lib/pdf/reader/point.rb#17
  sig { returns(::Numeric) }
  def y; end
end

# A simple receiver that prints all operaters and parameters in the content
# stream of a single page.
#
# source://pdf-reader//lib/pdf/reader/print_receiver.rb#9
class PDF::Reader::PrintReceiver
  # source://pdf-reader//lib/pdf/reader/print_receiver.rb#17
  sig { params(methodname: ::Symbol, args: T.untyped).void }
  def method_missing(methodname, *args); end

  # source://pdf-reader//lib/pdf/reader/print_receiver.rb#12
  sig { params(meth: T.untyped).returns(T::Boolean) }
  def respond_to?(meth); end
end

# Decrypts data using the RC4 algorithim defined in the PDF spec. Requires
# a decryption key, which is usually generated by PDF::Reader::StandardKeyBuilder
#
# source://pdf-reader//lib/pdf/reader/rc4_security_handler.rb#13
class PDF::Reader::Rc4SecurityHandler
  # source://pdf-reader//lib/pdf/reader/rc4_security_handler.rb#16
  sig { params(key: ::String).void }
  def initialize(key); end

  # 7.6.2 General Encryption Algorithm
  #
  # Algorithm 1: Encryption of data using the RC4 algorithm
  #
  # version <=3 or (version == 4 and CFM == V2)
  #
  # buf - a string to decrypt
  # ref - a PDF::Reader::Reference for the object to decrypt
  #
  #
  # source://pdf-reader//lib/pdf/reader/rc4_security_handler.rb#30
  sig { params(buf: ::String, ref: ::PDF::Reader::Reference).returns(::String) }
  def decrypt(buf, ref); end
end

# PDFs represent rectangles all over the place. They're 4 element arrays, like this:
#
#     [A, B, C, D]
#
# Four element arrays are yucky to work with though, so here's a class that's better.
# Initialize it with the 4 elements, and get utility functions (width, height, etc)
# for free.
#
# By convention the first two elements are x1, y1, the co-ords for the bottom left corner
# of the rectangle. The third and fourth elements are x2, y2, the co-ords for the top left
# corner of the rectangle. It's valid for the alternative corners to be used though, so
# we don't assume which is which.
#
# source://pdf-reader//lib/pdf/reader/rectangle.rb#21
class PDF::Reader::Rectangle
  # source://pdf-reader//lib/pdf/reader/rectangle.rb#36
  sig { params(x1: ::Numeric, y1: ::Numeric, x2: ::Numeric, y2: ::Numeric).void }
  def initialize(x1, y1, x2, y2); end

  # source://pdf-reader//lib/pdf/reader/rectangle.rb#59
  sig { params(other: ::PDF::Reader::Rectangle).returns(T::Boolean) }
  def ==(other); end

  # source://pdf-reader//lib/pdf/reader/rectangle.rb#91
  sig { params(degrees: ::Integer).void }
  def apply_rotation(degrees); end

  # source://pdf-reader//lib/pdf/reader/rectangle.rb#24
  sig { returns(::PDF::Reader::Point) }
  def bottom_left; end

  # source://pdf-reader//lib/pdf/reader/rectangle.rb#27
  sig { returns(::PDF::Reader::Point) }
  def bottom_right; end

  # source://pdf-reader//lib/pdf/reader/rectangle.rb#74
  sig { params(point: ::PDF::Reader::Point).returns(T::Boolean) }
  def contains?(point); end

  # source://pdf-reader//lib/pdf/reader/rectangle.rb#64
  sig { returns(::Numeric) }
  def height; end

  # A pdf-style 4-number array
  #
  # source://pdf-reader//lib/pdf/reader/rectangle.rb#81
  sig { returns(T::Array[::Numeric]) }
  def to_a; end

  # source://pdf-reader//lib/pdf/reader/rectangle.rb#30
  sig { returns(::PDF::Reader::Point) }
  def top_left; end

  # source://pdf-reader//lib/pdf/reader/rectangle.rb#33
  sig { returns(::PDF::Reader::Point) }
  def top_right; end

  # source://pdf-reader//lib/pdf/reader/rectangle.rb#69
  sig { returns(::Numeric) }
  def width; end

  private

  # source://pdf-reader//lib/pdf/reader/rectangle.rb#116
  sig { params(x1: ::Numeric, y1: ::Numeric, x2: ::Numeric, y2: ::Numeric).void }
  def set_corners(x1, y1, x2, y2); end

  class << self
    # source://pdf-reader//lib/pdf/reader/rectangle.rb#45
    sig { params(arr: T::Array[::Numeric]).returns(::PDF::Reader::Rectangle) }
    def from_array(arr); end
  end
end

# An internal PDF::Reader class that represents an indirect reference to a PDF Object
#
# source://pdf-reader//lib/pdf/reader/reference.rb#33
class PDF::Reader::Reference
  # Create a new Reference to an object with the specified id and revision number
  #
  # source://pdf-reader//lib/pdf/reader/reference.rb#42
  sig { params(id: ::Integer, gen: ::Integer).void }
  def initialize(id, gen); end

  # returns true if the provided object points to the same PDF Object as the
  # current object
  #
  # source://pdf-reader//lib/pdf/reader/reference.rb#62
  sig { params(obj: ::Object).returns(T::Boolean) }
  def ==(obj); end

  # returns true if the provided object points to the same PDF Object as the
  # current object
  #
  # source://pdf-reader//lib/pdf/reader/reference.rb#67
  def eql?(*args, **_arg1, &blk); end

  # source://pdf-reader//lib/pdf/reader/reference.rb#38
  sig { returns(::Integer) }
  def gen; end

  # returns a hash based on the PDF::Reference this object points to. Two
  # different Reference objects that point to the same PDF Object will
  # return an identical hash
  #
  # source://pdf-reader//lib/pdf/reader/reference.rb#73
  sig { returns(::Integer) }
  def hash; end

  # source://pdf-reader//lib/pdf/reader/reference.rb#35
  sig { returns(::Integer) }
  def id; end

  # returns the current Reference object in an array with a single element
  #
  # source://pdf-reader//lib/pdf/reader/reference.rb#49
  sig { returns(T::Array[::PDF::Reader::Reference]) }
  def to_a; end

  # returns the ID of this reference. Use with caution, ignores the generation id
  #
  # source://pdf-reader//lib/pdf/reader/reference.rb#55
  sig { returns(::Integer) }
  def to_i; end
end

# An example receiver that just records all callbacks generated by parsing
# a PDF file.
#
# Useful for testing the contents of a file in an rspec/test-unit suite.
#
# Usage:
#
#     PDF::Reader.open("somefile.pdf") do |reader|
#       receiver = PDF::Reader::RegisterReceiver.new
#       reader.page(1).walk(receiver)
#       callback = receiver.first_occurance_of(:show_text)
#       callback[:args].first.should == "Hellow World"
#     end
#
# source://pdf-reader//lib/pdf/reader/register_receiver.rb#23
class PDF::Reader::RegisterReceiver
  # source://pdf-reader//lib/pdf/reader/register_receiver.rb#29
  sig { void }
  def initialize; end

  # return the details for every time the specified callback was fired
  #
  # source://pdf-reader//lib/pdf/reader/register_receiver.rb#51
  sig { params(methodname: ::Symbol).returns(T::Array[T::Hash[::Symbol, T.untyped]]) }
  def all(methodname); end

  # source://pdf-reader//lib/pdf/reader/register_receiver.rb#56
  sig { params(methodname: ::Symbol).returns(T::Array[T::Array[T.untyped]]) }
  def all_args(methodname); end

  # source://pdf-reader//lib/pdf/reader/register_receiver.rb#26
  sig { returns(T::Array[T::Hash[::Symbol, T.untyped]]) }
  def callbacks; end

  # source://pdf-reader//lib/pdf/reader/register_receiver.rb#26
  def callbacks=(_arg0); end

  # count the number of times a callback fired
  #
  # source://pdf-reader//lib/pdf/reader/register_receiver.rb#45
  sig { params(methodname: ::Symbol).returns(::Integer) }
  def count(methodname); end

  # return the details for the final time the specified callback was fired
  #
  # source://pdf-reader//lib/pdf/reader/register_receiver.rb#68
  sig { params(methodname: ::Symbol).returns(T.nilable(T::Hash[::Symbol, T.untyped])) }
  def final_occurance_of(methodname); end

  # return the details for the first time the specified callback was fired
  #
  # source://pdf-reader//lib/pdf/reader/register_receiver.rb#62
  sig { params(methodname: ::Symbol).returns(T.nilable(T::Hash[::Symbol, T.untyped])) }
  def first_occurance_of(methodname); end

  # source://pdf-reader//lib/pdf/reader/register_receiver.rb#39
  sig { params(methodname: ::Symbol, args: T.untyped).void }
  def method_missing(methodname, *args); end

  # source://pdf-reader//lib/pdf/reader/register_receiver.rb#34
  sig { params(meth: T.untyped).returns(T::Boolean) }
  def respond_to?(meth); end

  # return the first occurance of a particular series of callbacks
  #
  # source://pdf-reader//lib/pdf/reader/register_receiver.rb#74
  sig { params(methods: ::Symbol).returns(T.nilable(T::Array[T::Hash[::Symbol, T.untyped]])) }
  def series(*methods); end
end

# mixin for common methods in Page and FormXobjects
#
# source://pdf-reader//lib/pdf/reader/resources.rb#10
class PDF::Reader::Resources
  # source://pdf-reader//lib/pdf/reader/resources.rb#13
  sig { params(objects: ::PDF::Reader::ObjectHash, resources: T::Hash[T.untyped, T.untyped]).void }
  def initialize(objects, resources); end

  # Returns a Hash of color spaces that are available to this page
  #
  # NOTE: this method de-serialise objects from the underlying PDF
  #       with no caching. You will want to cache the results instead
  #       of calling it over and over.
  #
  #
  # source://pdf-reader//lib/pdf/reader/resources.rb#25
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def color_spaces; end

  # Returns a Hash of fonts that are available to this page
  #
  # NOTE: this method de-serialise objects from the underlying PDF
  #       with no caching. You will want to cache the results instead
  #       of calling it over and over.
  #
  #
  # source://pdf-reader//lib/pdf/reader/resources.rb#36
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def fonts; end

  # Returns a Hash of external graphic states that are available to this
  # page
  #
  # NOTE: this method de-serialise objects from the underlying PDF
  #       with no caching. You will want to cache the results instead
  #       of calling it over and over.
  #
  #
  # source://pdf-reader//lib/pdf/reader/resources.rb#48
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def graphic_states; end

  # Returns a Hash of patterns that are available to this page
  #
  # NOTE: this method de-serialise objects from the underlying PDF
  #       with no caching. You will want to cache the results instead
  #       of calling it over and over.
  #
  #
  # source://pdf-reader//lib/pdf/reader/resources.rb#59
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def patterns; end

  # Returns an Array of procedure sets that are available to this page
  #
  # NOTE: this method de-serialise objects from the underlying PDF
  #       with no caching. You will want to cache the results instead
  #       of calling it over and over.
  #
  #
  # source://pdf-reader//lib/pdf/reader/resources.rb#70
  sig { returns(T::Array[::Symbol]) }
  def procedure_sets; end

  # Returns a Hash of properties sets that are available to this page
  #
  # NOTE: this method de-serialise objects from the underlying PDF
  #       with no caching. You will want to cache the results instead
  #       of calling it over and over.
  #
  #
  # source://pdf-reader//lib/pdf/reader/resources.rb#81
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def properties; end

  # Returns a Hash of shadings that are available to this page
  #
  # NOTE: this method de-serialise objects from the underlying PDF
  #       with no caching. You will want to cache the results instead
  #       of calling it over and over.
  #
  #
  # source://pdf-reader//lib/pdf/reader/resources.rb#92
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def shadings; end

  # Returns a Hash of XObjects that are available to this page
  #
  # NOTE: this method de-serialise objects from the underlying PDF
  #       with no caching. You will want to cache the results instead
  #       of calling it over and over.
  #
  #
  # source://pdf-reader//lib/pdf/reader/resources.rb#103
  sig { returns(T::Hash[::Symbol, ::PDF::Reader::Stream]) }
  def xobjects; end
end

# Examines the Encrypt entry of a PDF trailer (if any) and returns an object that's
# able to decrypt the file.
#
# source://pdf-reader//lib/pdf/reader/security_handler_factory.rb#8
class PDF::Reader::SecurityHandlerFactory
  class << self
    # source://pdf-reader//lib/pdf/reader/security_handler_factory.rb#11
    sig do
      params(
        encrypt: T::Hash[::Symbol, T.untyped],
        doc_id: T.nilable(T::Array[T.untyped]),
        password: T.nilable(::String)
      ).returns(T.any(::PDF::Reader::AesV2SecurityHandler, ::PDF::Reader::AesV3SecurityHandler, ::PDF::Reader::NullSecurityHandler, ::PDF::Reader::Rc4SecurityHandler, ::PDF::Reader::UnimplementedSecurityHandler))
    end
    def build(encrypt, doc_id, password); end

    # source://pdf-reader//lib/pdf/reader/security_handler_factory.rb#27
    sig do
      params(
        encrypt: T::Hash[::Symbol, T.untyped],
        doc_id: T::Array[T.untyped],
        password: ::String
      ).returns(T.any(::PDF::Reader::AesV2SecurityHandler, ::PDF::Reader::Rc4SecurityHandler))
    end
    def build_standard_handler(encrypt, doc_id, password); end

    # source://pdf-reader//lib/pdf/reader/security_handler_factory.rb#47
    sig do
      params(
        encrypt: T::Hash[::Symbol, T.untyped],
        doc_id: T::Array[T.untyped],
        password: ::String
      ).returns(::PDF::Reader::AesV3SecurityHandler)
    end
    def build_v5_handler(encrypt, doc_id, password); end

    # This handler supports all encryption that follows upto PDF 1.5 spec (revision 4)
    #
    # source://pdf-reader//lib/pdf/reader/security_handler_factory.rb#59
    sig { params(encrypt: T::Hash[::Symbol, T.untyped]).returns(T::Boolean) }
    def standard?(encrypt); end

    # This handler supports both
    # - AES-256 encryption defined in PDF 1.7 Extension Level 3 ('revision 5')
    # - AES-256 encryption defined in PDF 2.0 ('revision 6')
    #
    # source://pdf-reader//lib/pdf/reader/security_handler_factory.rb#73
    sig { params(encrypt: T::Hash[::Symbol, T.untyped]).returns(T.untyped) }
    def standard_v5?(encrypt); end
  end
end

# Processes the Encrypt dict from an encrypted PDF and a user provided
# password and returns a key that can decrypt the file.
#
# This can generate a key compatible with the following standard encryption algorithms:
#
# * Version 1-3, all variants
# * Version 4, V2 (RC4) and AESV2
#
# source://pdf-reader//lib/pdf/reader/standard_key_builder.rb#17
class PDF::Reader::StandardKeyBuilder
  # source://pdf-reader//lib/pdf/reader/standard_key_builder.rb#30
  sig { params(opts: T::Hash[::Symbol, T.untyped]).void }
  def initialize(opts = T.unsafe(nil)); end

  # Takes a string containing a user provided password.
  #
  # If the password matches the file, then a string containing a key suitable for
  # decrypting the file will be returned. If the password doesn't match the file,
  # and exception will be raised.
  #
  #
  # @raise [PDF::Reader::EncryptedPDFError]
  #
  # source://pdf-reader//lib/pdf/reader/standard_key_builder.rb#53
  sig { params(pass: ::String).returns(::String) }
  def key(pass = T.unsafe(nil)); end

  private

  # 7.6.3.4 Password Algorithms
  #
  # Algorithm 7 - Authenticating the Owner Password
  #
  # Used to test Owner passwords
  #
  # if the string is a valid owner password this will return the user
  # password that should be used to decrypt the document.
  #
  # if the supplied password is not a valid owner password for this document
  # then it returns nil
  #
  #
  # source://pdf-reader//lib/pdf/reader/standard_key_builder.rb#93
  sig { params(pass: ::String).returns(T.nilable(::String)) }
  def auth_owner_pass(pass); end

  # Algorithm 6 - Authenticating the User Password
  #
  # Used to test User passwords
  #
  # if the string is a valid user password this will return the user
  # password that should be used to decrypt the document.
  #
  # if the supplied password is not a valid user password for this document
  # then it returns nil
  #
  #
  # source://pdf-reader//lib/pdf/reader/standard_key_builder.rb#126
  sig { params(pass: ::String).returns(T.nilable(::String)) }
  def auth_user_pass(pass); end

  # source://pdf-reader//lib/pdf/reader/standard_key_builder.rb#141
  sig { params(user_pass: ::String).returns(::String) }
  def make_file_key(user_pass); end

  # Pads supplied password to 32bytes using PassPadBytes as specified on
  # pp61 of spec
  #
  #
  # source://pdf-reader//lib/pdf/reader/standard_key_builder.rb#67
  sig { params(p: T.nilable(::String)).returns(::String) }
  def pad_pass(p = T.unsafe(nil)); end

  # source://pdf-reader//lib/pdf/reader/standard_key_builder.rb#76
  sig { params(buf: ::String, int: ::Integer).returns(::String) }
  def xor_each_byte(buf, int); end
end

# 7.6.3.3 Encryption Key Algorithm (pp61)
#
# needs a document's user password to build a key for decrypting an
# encrypted PDF document
#
# source://pdf-reader//lib/pdf/reader/standard_key_builder.rb#24
PDF::Reader::StandardKeyBuilder::PassPadBytes = T.let(T.unsafe(nil), Array)

# An internal PDF::Reader class that represents a stream object from a PDF. Stream
# objects have 2 components, a dictionary that describes the content (size,
# compression, etc) and a stream of bytes.
#
# source://pdf-reader//lib/pdf/reader/stream.rb#36
class PDF::Reader::Stream
  # Creates a new stream with the specified dictionary and data. The dictionary
  # should be a standard ruby hash, the data should be a standard ruby string.
  #
  # source://pdf-reader//lib/pdf/reader/stream.rb#47
  sig { params(hash: T::Hash[::Symbol, T.untyped], data: ::String).void }
  def initialize(hash, data); end

  # source://pdf-reader//lib/pdf/reader/stream.rb#41
  sig { returns(::String) }
  def data; end

  # source://pdf-reader//lib/pdf/reader/stream.rb#41
  def data=(_arg0); end

  # source://pdf-reader//lib/pdf/reader/stream.rb#38
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def hash; end

  # source://pdf-reader//lib/pdf/reader/stream.rb#38
  def hash=(_arg0); end

  # apply this streams filters to its data and return the result.
  #
  # source://pdf-reader//lib/pdf/reader/stream.rb#55
  sig { returns(::String) }
  def unfiltered_data; end
end

# Throughout the pdf-reader codebase, repeated calculations which can benefit
# from caching are made In some cases, caching and reusing results can not
# only save CPU cycles but also greatly reduce memory requirements But at the
# same time, we don't want to throw away thread safety We have two
# interchangeable thread-safe cache implementations:
#
# source://pdf-reader//lib/pdf/reader/synchronized_cache.rb#22
class PDF::Reader::SynchronizedCache
  # source://pdf-reader//lib/pdf/reader/synchronized_cache.rb#24
  sig { void }
  def initialize; end

  # source://pdf-reader//lib/pdf/reader/synchronized_cache.rb#29
  sig { params(key: ::Object).returns(T.untyped) }
  def [](key); end

  # source://pdf-reader//lib/pdf/reader/synchronized_cache.rb#33
  sig { params(key: ::Object, value: T.nilable(::Object)).returns(T.untyped) }
  def []=(key, value); end
end

# A value object that represents one or more consecutive characters on a page.
#
# source://pdf-reader//lib/pdf/reader/text_run.rb#7
class PDF::Reader::TextRun
  include ::Comparable

  # source://pdf-reader//lib/pdf/reader/text_run.rb#25
  sig { params(x: ::Numeric, y: ::Numeric, width: ::Numeric, font_size: ::Numeric, text: ::String).void }
  def initialize(x, y, width, font_size, text); end

  # @raise [ArgumentError]
  #
  # source://pdf-reader//lib/pdf/reader/text_run.rb#85
  sig { params(other: ::PDF::Reader::TextRun).returns(::PDF::Reader::TextRun) }
  def +(other); end

  # Allows collections of TextRun objects to be sorted. They will be sorted
  # in order of their position on a cartesian plain - Top Left to Bottom Right
  #
  # source://pdf-reader//lib/pdf/reader/text_run.rb#38
  sig { params(other: ::PDF::Reader::Point).returns(::Numeric) }
  def <=>(other); end

  # source://pdf-reader//lib/pdf/reader/text_run.rb#65
  sig { returns(::Numeric) }
  def endx; end

  # source://pdf-reader//lib/pdf/reader/text_run.rb#70
  sig { returns(::Numeric) }
  def endy; end

  # source://pdf-reader//lib/pdf/reader/text_run.rb#17
  sig { returns(::Numeric) }
  def font_size; end

  # source://pdf-reader//lib/pdf/reader/text_run.rb#96
  sig { returns(::String) }
  def inspect; end

  # source://pdf-reader//lib/pdf/reader/text_run.rb#101
  sig { params(other_run: ::PDF::Reader::TextRun).returns(T::Boolean) }
  def intersect?(other_run); end

  # return what percentage of this text run is overlapped by another run
  #
  # source://pdf-reader//lib/pdf/reader/text_run.rb#108
  sig { params(other_run: ::PDF::Reader::TextRun).returns(::Numeric) }
  def intersection_area_percent(other_run); end

  # source://pdf-reader//lib/pdf/reader/text_run.rb#75
  sig { returns(::Numeric) }
  def mean_character_width; end

  # source://pdf-reader//lib/pdf/reader/text_run.rb#80
  sig { params(other: ::PDF::Reader::TextRun).returns(T::Boolean) }
  def mergable?(other); end

  # source://pdf-reader//lib/pdf/reader/text_run.rb#11
  sig { returns(::PDF::Reader::Point) }
  def origin; end

  # source://pdf-reader//lib/pdf/reader/text_run.rb#20
  sig { returns(::String) }
  def text; end

  # source://pdf-reader//lib/pdf/reader/text_run.rb#22
  def to_s(*args, **_arg1, &blk); end

  # source://pdf-reader//lib/pdf/reader/text_run.rb#14
  sig { returns(::Numeric) }
  def width; end

  # source://pdf-reader//lib/pdf/reader/text_run.rb#55
  sig { returns(::Numeric) }
  def x; end

  # source://pdf-reader//lib/pdf/reader/text_run.rb#60
  sig { returns(::Numeric) }
  def y; end

  private

  # source://pdf-reader//lib/pdf/reader/text_run.rb#121
  sig { returns(::Numeric) }
  def area; end

  # Assume string encoding is marked correctly and we can trust String#size to return a
  # character count
  #
  # source://pdf-reader//lib/pdf/reader/text_run.rb#133
  sig { returns(::Float) }
  def character_count; end

  # source://pdf-reader//lib/pdf/reader/text_run.rb#126
  sig { returns(T::Range[::Numeric]) }
  def mergable_range; end
end

# An internal PDF::Reader class that represents a single token from a PDF file.
#
# Behaves exactly like a Ruby String - it basically exists for convenience.
#
# source://pdf-reader//lib/pdf/reader/token.rb#35
class PDF::Reader::Token < ::String
  # Creates a new token with the specified value
  #
  # source://pdf-reader//lib/pdf/reader/token.rb#39
  sig { params(val: T.untyped).void }
  def initialize(val); end
end

# co-ordinate systems in PDF files are specified using a 3x3 matrix that looks
# something like this:
#
#   [ a b 0 ]
#   [ c d 0 ]
#   [ e f 1 ]
#
# Because the final column never changes, we can represent each matrix using
# only 6 numbers. This is important to save CPU time, memory and GC pressure
# caused by allocating too many unnecessary objects.
#
# source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#16
class PDF::Reader::TransformationMatrix
  # source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#36
  sig { params(a: ::Numeric, b: ::Numeric, c: ::Numeric, d: ::Numeric, e: ::Numeric, f: ::Numeric).void }
  def initialize(a, b, c, d, e, f); end

  # source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#18
  sig { returns(::Numeric) }
  def a; end

  # source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#21
  sig { returns(::Numeric) }
  def b; end

  # source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#24
  sig { returns(::Numeric) }
  def c; end

  # source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#27
  sig { returns(::Numeric) }
  def d; end

  # source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#30
  sig { returns(::Numeric) }
  def e; end

  # source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#33
  sig { returns(::Numeric) }
  def f; end

  # Optimised method for when the second matrix in the calculation is
  # a simple horizontal displacement.
  #
  # Like this:
  #
  #   [ 1 2 0 ]   [ 1  0 0 ]
  #   [ 3 4 0 ] x [ 0  1 0 ]
  #   [ 5 6 1 ]   [ e2 0 1 ]
  #
  #
  # source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#119
  sig { params(e2: ::Numeric).void }
  def horizontal_displacement_multiply!(e2); end

  # source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#46
  sig { returns(::String) }
  def inspect; end

  # multiply this matrix with another.
  #
  # the second matrix is represented by the 6 scalar values that are changeable
  # in a PDF transformation matrix.
  #
  # WARNING: This mutates the current matrix to avoid allocating memory when
  #          we don't need too. Matrices are multiplied ALL THE FREAKING TIME
  #          so this is a worthwhile optimisation
  #
  # NOTE: When multiplying matrices, ordering matters. Double check
  #       the PDF spec to ensure you're multiplying things correctly.
  #
  # NOTE: see Section 8.3.3, PDF 32000-1:2008, pp 119
  #
  # NOTE: The if statements in this method are ordered to prefer optimisations
  #       that allocate fewer objects
  #
  # TODO: it might be worth adding an optimised path for vertical
  #       displacement to speed up processing documents that use vertical
  #       writing systems
  #
  #
  # source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#79
  sig do
    params(
      a: ::Numeric,
      b: ::Numeric,
      c: ::Numeric,
      d: ::Numeric,
      e: ::Numeric,
      f: ::Numeric
    ).returns(::PDF::Reader::TransformationMatrix)
  end
  def multiply!(a, b, c, d, e, f); end

  # source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#51
  sig { returns([::Numeric]) }
  def to_a; end

  private

  # A general solution for multiplying two matrices when we know all values
  # in the final column are fixed. This is the fallback method for when none
  # of the optimised methods are applicable.
  #
  # Like this:
  #
  #   [ a b 0 ]   [ a b 0 ]
  #   [ c d 0 ] x [ c d 0 ]
  #   [ e f 1 ]   [ e f 1 ]
  #
  #
  # source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#217
  sig { params(a2: ::Numeric, b2: ::Numeric, c2: ::Numeric, d2: ::Numeric, e2: ::Numeric, f2: ::Numeric).void }
  def faster_multiply!(a2, b2, c2, d2, e2, f2); end

  # Optimised method for when the first matrix in the calculation is
  # a simple horizontal displacement.
  #
  # Like this:
  #
  #   [ 1 0 0 ]   [ 1 2 0 ]
  #   [ 0 1 0 ] x [ 3 4 0 ]
  #   [ 5 0 1 ]   [ 5 6 1 ]
  #
  #
  # source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#135
  sig { params(a2: ::Numeric, b2: ::Numeric, c2: ::Numeric, d2: ::Numeric, e2: ::Numeric, f2: ::Numeric).void }
  def horizontal_displacement_multiply_reversed!(a2, b2, c2, d2, e2, f2); end

  # A general solution to multiplying two 3x3 matrixes. This is correct in all cases,
  # but slower due to excessive object allocations. It's not actually used in any
  # active code paths, but is here for reference. Use faster_multiply instead.
  #
  # Like this:
  #
  #   [ a b 0 ]   [ a b 0 ]
  #   [ c d 0 ] x [ c d 0 ]
  #   [ e f 1 ]   [ e f 1 ]
  #
  #
  # source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#196
  sig { params(a2: ::Numeric, b2: ::Numeric, c2: ::Numeric, d2: ::Numeric, e2: ::Numeric, f2: ::Numeric).void }
  def regular_multiply!(a2, b2, c2, d2, e2, f2); end

  # Optimised method for when the second matrix in the calculation is
  # an X and Y scale
  #
  # Like this:
  #
  #   [ 1 2 0 ]   [ 5 0 0 ]
  #   [ 3 4 0 ] x [ 0 5 0 ]
  #   [ 5 6 1 ]   [ 0 0 1 ]
  #
  #
  # source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#155
  sig { params(a2: ::Numeric, b2: ::Numeric, c2: ::Numeric, d2: ::Numeric, e2: ::Numeric, f2: ::Numeric).void }
  def xy_scaling_multiply!(a2, b2, c2, d2, e2, f2); end

  # Optimised method for when the first matrix in the calculation is
  # an X and Y scale
  #
  # Like this:
  #
  #   [ 5 0 0 ]   [ 1 2 0 ]
  #   [ 0 5 0 ] x [ 3 4 0 ]
  #   [ 0 0 1 ]   [ 5 6 1 ]
  #
  #
  # source://pdf-reader//lib/pdf/reader/transformation_matrix.rb#175
  sig { params(a2: ::Numeric, b2: ::Numeric, c2: ::Numeric, d2: ::Numeric, e2: ::Numeric, f2: ::Numeric).void }
  def xy_scaling_multiply_reversed!(a2, b2, c2, d2, e2, f2); end
end

# Cast untrusted input (usually parsed out of a PDF file) to a known type
#
# source://pdf-reader//lib/pdf/reader/type_check.rb#10
class PDF::Reader::TypeCheck
  class << self
    # source://pdf-reader//lib/pdf/reader/type_check.rb#13
    sig { params(obj: T.untyped).returns(::Integer) }
    def cast_to_int!(obj); end

    # source://pdf-reader//lib/pdf/reader/type_check.rb#26
    sig { params(obj: T.untyped).returns(::Numeric) }
    def cast_to_numeric!(obj); end

    # source://pdf-reader//lib/pdf/reader/type_check.rb#77
    sig { params(obj: T.untyped).returns(T::Hash[::Symbol, T.untyped]) }
    def cast_to_pdf_dict!(obj); end

    # source://pdf-reader//lib/pdf/reader/type_check.rb#88
    sig { params(obj: T.untyped).returns(T::Hash[::Symbol, ::PDF::Reader::Stream]) }
    def cast_to_pdf_dict_with_stream_values!(obj); end

    # source://pdf-reader//lib/pdf/reader/type_check.rb#41
    sig { params(string: T.untyped).returns(::String) }
    def cast_to_string!(string); end

    # source://pdf-reader//lib/pdf/reader/type_check.rb#54
    sig { params(obj: T.untyped).returns(::Symbol) }
    def cast_to_symbol(obj); end

    # source://pdf-reader//lib/pdf/reader/type_check.rb#67
    sig { params(obj: T.untyped).returns(::Symbol) }
    def cast_to_symbol!(obj); end
  end
end

# Security handler for when we don't support the flavour of encryption
# used in a PDF.
#
# source://pdf-reader//lib/pdf/reader/unimplemented_security_handler.rb#9
class PDF::Reader::UnimplementedSecurityHandler
  # @raise [PDF::Reader::EncryptedPDFError]
  #
  # source://pdf-reader//lib/pdf/reader/unimplemented_security_handler.rb#16
  sig { params(buf: ::String, ref: ::PDF::Reader::Reference).returns(::String) }
  def decrypt(buf, ref); end

  class << self
    # source://pdf-reader//lib/pdf/reader/unimplemented_security_handler.rb#11
    sig { params(encrypt: T::Hash[::Symbol, T.untyped]).returns(T::Boolean) }
    def supports?(encrypt); end
  end
end

# an exception that is raised when a PDF follows the specs but uses a feature
# that we don't support just yet
#
# source://pdf-reader//lib/pdf/reader/error.rb#85
class PDF::Reader::UnsupportedFeatureError < ::RuntimeError; end

# Page#walk will execute the content stream of a page, calling methods on a receiver class
# provided by the user. Each operator has a specific set of parameters it expects, and we
# wrap the users receiver class in this one to verify the PDF uses valid parameters.
#
# Without these checks, users can't be confident about the number of parameters they'll receive
# for an operator, or what the type of those parameters will be. Everyone ends up building their
# own type safety guard clauses and it's tedious.
#
# Not all operators have type safety implemented yet, but we can expand the number over time.
#
# source://pdf-reader//lib/pdf/reader/validating_receiver.rb#17
class PDF::Reader::ValidatingReceiver
  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#20
  sig { params(wrapped: T.untyped).void }
  def initialize(wrapped); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#248
  sig { params(args: T.untyped).void }
  def begin_inline_image(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#253
  sig { params(args: T.untyped).void }
  def begin_inline_image_data(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#65
  sig { params(args: T.untyped).void }
  def begin_text_object(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#47
  sig { params(args: T.untyped).void }
  def concatenate_matrix(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#260
  sig { params(args: T.untyped).void }
  def end_inline_image(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#70
  sig { params(args: T.untyped).void }
  def end_text_object(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#234
  sig { params(args: T.untyped).void }
  def invoke_xobject(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#279
  sig { params(methodname: ::Symbol, args: T.untyped).void }
  def method_missing(methodname, *args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#146
  sig { params(args: T.untyped).void }
  def move_text_position(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#156
  sig { params(args: T.untyped).void }
  def move_text_position_and_set_leading(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#210
  sig { params(args: T.untyped).void }
  def move_to_next_line_and_show_text(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#180
  sig { params(args: T.untyped).void }
  def move_to_start_of_next_line(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#25
  sig { params(page: ::PDF::Reader::Page).void }
  def page=(page); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#274
  sig { params(meth: T.untyped).returns(T::Boolean) }
  def respond_to?(meth); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#38
  sig { params(args: T.untyped).void }
  def restore_graphics_state(*args); end

  # Graphics State Operators
  #
  #
  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#33
  sig { params(args: T.untyped).void }
  def save_graphics_state(*args); end

  # Text State Operators
  #
  #
  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#78
  sig { params(args: T.untyped).void }
  def set_character_spacing(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#87
  sig { params(args: T.untyped).void }
  def set_horizontal_text_scaling(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#219
  sig { params(args: T.untyped).void }
  def set_spacing_next_line_show_text(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#96
  sig { params(args: T.untyped).void }
  def set_text_font_and_size(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#106
  sig { params(args: T.untyped).void }
  def set_text_leading(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#166
  sig { params(args: T.untyped).void }
  def set_text_matrix_and_text_line_matrix(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#115
  sig { params(args: T.untyped).void }
  def set_text_rendering_mode(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#124
  sig { params(args: T.untyped).void }
  def set_text_rise(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#133
  sig { params(args: T.untyped).void }
  def set_word_spacing(*args); end

  # Text Showing Operators
  #
  #
  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#188
  sig { params(args: T.untyped).void }
  def show_text(*args); end

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#197
  sig { params(args: T.untyped).void }
  def show_text_with_positioning(*args); end

  private

  # source://pdf-reader//lib/pdf/reader/validating_receiver.rb#286
  sig { params(methodname: T.untyped, args: T.untyped).void }
  def call_wrapped(methodname, *args); end
end

# source://pdf-reader//lib/pdf/reader/width_calculator/built_in.rb#9
module PDF::Reader::WidthCalculator; end

# Type1 fonts can be one of 14 "built in" standard fonts. In these cases,
# the reader is expected to have it's own copy of the font metrics.
# see Section 9.6.2.2, PDF 32000-1:2008, pp 256
#
# source://pdf-reader//lib/pdf/reader/width_calculator/built_in.rb#14
class PDF::Reader::WidthCalculator::BuiltIn
  # source://pdf-reader//lib/pdf/reader/width_calculator/built_in.rb#26
  sig { params(font: ::PDF::Reader::Font).void }
  def initialize(font); end

  # source://pdf-reader//lib/pdf/reader/width_calculator/built_in.rb#42
  sig { params(code_point: T.nilable(::Integer)).returns(::Numeric) }
  def glyph_width(code_point); end

  private

  # source://pdf-reader//lib/pdf/reader/width_calculator/built_in.rb#61
  sig { params(code_point: ::Integer).returns(T::Boolean) }
  def control_character?(code_point); end

  # source://pdf-reader//lib/pdf/reader/width_calculator/built_in.rb#67
  sig { params(font_name: T.nilable(::Symbol)).returns(::String) }
  def extract_basefont(font_name); end
end

# source://pdf-reader//lib/pdf/reader/width_calculator/built_in.rb#17
PDF::Reader::WidthCalculator::BuiltIn::BUILTINS = T.let(T.unsafe(nil), Array)

# CIDFontType0 or CIDFontType2 use DW (integer) and W (array) to determine
# codepoint widths, note that CIDFontType2 will contain a true type font
# program which could be used to calculate width, however, a conforming writer
# is supposed to convert the widths for the codepoints used into the W array
# so that it can be used.
# see Section 9.7.4.1, PDF 32000-1:2008, pp 269-270
#
# source://pdf-reader//lib/pdf/reader/width_calculator/composite.rb#13
class PDF::Reader::WidthCalculator::Composite
  # source://pdf-reader//lib/pdf/reader/width_calculator/composite.rb#16
  sig { params(font: ::PDF::Reader::Font).void }
  def initialize(font); end

  # source://pdf-reader//lib/pdf/reader/width_calculator/composite.rb#24
  sig { params(code_point: T.nilable(::Integer)).returns(::Numeric) }
  def glyph_width(code_point); end
end

# Calculates the width of a glyph in a TrueType font
#
# source://pdf-reader//lib/pdf/reader/width_calculator/true_type.rb#8
class PDF::Reader::WidthCalculator::TrueType
  # source://pdf-reader//lib/pdf/reader/width_calculator/true_type.rb#11
  sig { params(font: ::PDF::Reader::Font).void }
  def initialize(font); end

  # source://pdf-reader//lib/pdf/reader/width_calculator/true_type.rb#22
  sig { params(code_point: T.nilable(::Integer)).returns(::Numeric) }
  def glyph_width(code_point); end

  private

  # source://pdf-reader//lib/pdf/reader/width_calculator/true_type.rb#45
  sig { params(code_point: ::Integer).returns(T.nilable(::Numeric)) }
  def glyph_width_from_descriptor(code_point); end

  # TODO convert Type3 units 1000 units => 1 text space unit
  #
  # source://pdf-reader//lib/pdf/reader/width_calculator/true_type.rb#31
  sig { params(code_point: ::Integer).returns(T.nilable(::Numeric)) }
  def glyph_width_from_font(code_point); end
end

# Calculates the width of a glyph in a Type One or Type Three
#
# source://pdf-reader//lib/pdf/reader/width_calculator/type_one_or_three.rb#8
class PDF::Reader::WidthCalculator::TypeOneOrThree
  # source://pdf-reader//lib/pdf/reader/width_calculator/type_one_or_three.rb#11
  sig { params(font: ::PDF::Reader::Font).void }
  def initialize(font); end

  # source://pdf-reader//lib/pdf/reader/width_calculator/type_one_or_three.rb#22
  sig { params(code_point: T.nilable(::Integer)).returns(::Numeric) }
  def glyph_width(code_point); end
end

# Type0 (or Composite) fonts are a "root font" that rely on a "descendant font"
# to do the heavy lifting. The "descendant font" is a CID-Keyed font.
# see Section 9.7.1, PDF 32000-1:2008, pp 267
# so if we are calculating a Type0 font width, we just pass off to
# the descendant font
#
# source://pdf-reader//lib/pdf/reader/width_calculator/type_zero.rb#12
class PDF::Reader::WidthCalculator::TypeZero
  # source://pdf-reader//lib/pdf/reader/width_calculator/type_zero.rb#15
  sig { params(font: ::PDF::Reader::Font).void }
  def initialize(font); end

  # source://pdf-reader//lib/pdf/reader/width_calculator/type_zero.rb#20
  sig { params(code_point: T.nilable(::Integer)).returns(::Numeric) }
  def glyph_width(code_point); end
end

# An internal PDF::Reader class that represents the XRef table in a PDF file as a
# hash-like object.
#
# An Xref table is a map of object identifiers and byte offsets. Any time a particular
# object needs to be found, the Xref table is used to find where it is stored in the
# file.
#
# Hash keys are object ids, values are either:
#
# * a byte offset where the object starts (regular PDF objects)
# * a PDF::Reader::Reference instance that points to a stream that contains the
#   desired object (PDF objects embedded in an object stream)
#
# The class behaves much like a standard Ruby hash, including the use of
# the Enumerable mixin. The key difference is no []= method - the hash
# is read only.
#
#
# source://pdf-reader//lib/pdf/reader/xref.rb#49
class PDF::Reader::XRef
  extend T::Generic
  include ::Enumerable

  Elem = type_member

  # create a new Xref table based on the contents of the supplied io object
  #
  # io - must be an IO object, generally either a file or a StringIO
  #
  #
  # source://pdf-reader//lib/pdf/reader/xref.rb#65
  sig { params(io: T.any(::IO, ::StringIO, ::Tempfile)).void }
  def initialize(io); end

  # returns the byte offset for the specified PDF object.
  #
  # ref - a PDF::Reader::Reference object containing an object ID and revision number
  #
  # source://pdf-reader//lib/pdf/reader/xref.rb#85
  sig { params(ref: T.untyped).returns(T.untyped) }
  def [](ref); end

  # iterate over each object in the xref table
  #
  # @override(allow_incompatible: true)
  #
  # source://pdf-reader//lib/pdf/reader/xref.rb#95
  sig { override.params(block: T.proc.params(arg0: ::PDF::Reader::Reference).returns(T.untyped)).void }
  def each(&block); end

  # return the number of objects in this file. Objects with multiple generations are
  # only counter once.
  #
  #
  # source://pdf-reader//lib/pdf/reader/xref.rb#77
  sig { returns(T.untyped) }
  def size; end

  # source://pdf-reader//lib/pdf/reader/xref.rb#57
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def trailer; end

  private

  # Returns the offset of the PDF document in the +stream+. In theory this
  # should always be 0, but all sort of crazy junk is prefixed to PDF files
  # in the real world.
  #
  # Checks up to 1024 chars into the file,
  # returns nil if no PDF data detected.
  # Adobe PDF 1.4 spec (3.4.1) 12. Acrobat viewers require only that the
  # header appear somewhere within the first 1024 bytes of the file
  #
  #
  # source://pdf-reader//lib/pdf/reader/xref.rb#285
  sig { params(io: T.any(::IO, ::StringIO, ::Tempfile)).returns(T.nilable(::Integer)) }
  def calc_junk_offset(io); end

  # Read a xref table from the underlying buffer.
  #
  # If offset is specified the table will be loaded from there, otherwise the
  # default offset will be located and used.
  #
  # After seeking to the offset, processing is handed of to either load_xref_table()
  # or load_xref_stream() based on what we find there.
  #
  #
  # @raise [PDF::Reader::MalformedPDFError]
  #
  # source://pdf-reader//lib/pdf/reader/xref.rb#114
  sig { params(offset: T.nilable(::Integer)).returns(T::Hash[::Symbol, T.untyped]) }
  def load_offsets(offset = T.unsafe(nil)); end

  # Read an XRef stream from the underlying buffer instead of a traditional xref table.
  #
  #
  # source://pdf-reader//lib/pdf/reader/xref.rb#191
  sig { params(stream: ::PDF::Reader::Stream).returns(T::Hash[::Symbol, T.untyped]) }
  def load_xref_stream(stream); end

  # Assumes the underlying buffer is positioned at the start of a traditional
  # Xref table and processes it into memory.
  #
  #
  # source://pdf-reader//lib/pdf/reader/xref.rb#147
  sig { params(buf: ::PDF::Reader::Buffer).returns(T::Hash[::Symbol, T.untyped]) }
  def load_xref_table(buf); end

  # Wrap the io stream we're working with in a buffer that can tokenise it for us.
  #
  # We create multiple buffers so we can be tokenising multiple sections of the file
  # at the same time without worrying about clearing the buffers contents.
  #
  #
  # source://pdf-reader//lib/pdf/reader/xref.rb#264
  sig { params(offset: ::Integer).returns(::PDF::Reader::Buffer) }
  def new_buffer(offset = T.unsafe(nil)); end

  # Stores an offset value for a particular PDF object ID and revision number
  #
  #
  # source://pdf-reader//lib/pdf/reader/xref.rb#271
  sig do
    params(
      id: ::Integer,
      gen: ::Integer,
      offset: T.any(::Integer, ::PDF::Reader::Reference)
    ).returns(T.any(::Integer, ::PDF::Reader::Reference))
  end
  def store(id, gen, offset); end

  # XRef streams pack info into integers 1-N bytes wide. Depending on the number of
  # bytes they need to be converted to an int in different ways.
  #
  #
  # source://pdf-reader//lib/pdf/reader/xref.rb#239
  sig { params(bytes: T.nilable(::String)).returns(::Integer) }
  def unpack_bytes(bytes); end
end

# There's no point rendering zero-width characters
#
# source://pdf-reader//lib/pdf/reader/zero_width_runs_filter.rb#7
class PDF::Reader::ZeroWidthRunsFilter
  class << self
    # source://pdf-reader//lib/pdf/reader/zero_width_runs_filter.rb#10
    sig { params(runs: T::Array[::PDF::Reader::TextRun]).returns(T::Array[::PDF::Reader::TextRun]) }
    def exclude_zero_width_runs(runs); end
  end
end
