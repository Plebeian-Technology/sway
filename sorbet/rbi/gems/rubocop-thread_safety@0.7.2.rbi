# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-thread_safety` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-thread_safety`.


# source://rubocop-thread_safety//lib/rubocop/thread_safety.rb#3
module RuboCop; end

# source://rubocop-thread_safety//lib/rubocop/cop/mixin/operation_with_threadsafe_result.rb#4
module RuboCop::Cop; end

# Common functionality for checking if a well-known operation
# produces an object with thread-safe semantics.
#
# source://rubocop-thread_safety//lib/rubocop/cop/mixin/operation_with_threadsafe_result.rb#7
module RuboCop::Cop::OperationWithThreadsafeResult
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop-thread_safety//lib/rubocop/cop/mixin/operation_with_threadsafe_result.rb#11
  def operation_produces_threadsafe_object?(param0 = T.unsafe(nil)); end
end

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#5
module RuboCop::Cop::ThreadSafety; end

# Avoid mutating class and module attributes.
#
# They are implemented by class variables, which are not thread-safe.
#
# @example
#   # bad
#   class User
#   cattr_accessor :current_user
#   end
#
# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#15
class RuboCop::Cop::ThreadSafety::ClassAndModuleAttributes < ::RuboCop::Cop::Base
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#32
  def attr?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#39
  def attr_internal?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#46
  def class_attr?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#25
  def mattr?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#52
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#77
  def class_attribute_allowed?; end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#65
  def defined_in_singleton_class?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#60
  def singleton_attr?(node); end
end

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#16
RuboCop::Cop::ThreadSafety::ClassAndModuleAttributes::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#17
RuboCop::Cop::ThreadSafety::ClassAndModuleAttributes::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Avoid class instance variables.
#
# @example
#   # bad
#   class User
#   def self.notify(info)
#   @info = validate(info)
#   Notifier.new(@info).deliver
#   end
#   end
#
#   class Model
#   class << self
#   def table_name(name)
#   @table_name = name
#   end
#   end
#   end
#
#   class Host
#   %i[uri port].each do |key|
#   define_singleton_method("#{key}=") do |value|
#   instance_variable_set("@#{key}", value)
#   end
#   end
#   end
#
#   module Example
#   module ClassMethods
#   def test(params)
#   @params = params
#   end
#   end
#   end
#
#   module Example
#   class_methods do
#   def test(params)
#   @params = params
#   end
#   end
#   end
#
#   module Example
#   module_function
#
#   def test(params)
#   @params = params
#   end
#   end
#
#   module Example
#   def test(params)
#   @params = params
#   end
#
#   module_function :test
#   end
#
# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#64
class RuboCop::Cop::ThreadSafety::ClassInstanceVariable < ::RuboCop::Cop::Base
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#253
  def class_eval_scope?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#218
  def class_methods_module?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#77
  def instance_variable_get_call?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#72
  def instance_variable_set_call?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#223
  def module_function_for?(param0 = T.unsafe(nil), param1); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#228
  def new_lexical_scope?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#81
  def on_ivar(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#81
  def on_ivasgn(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#90
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#101
  def class_method_definition?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#165
  def in_class_eval?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#128
  def in_def_class_methods?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#132
  def in_def_class_methods_dsl?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#141
  def in_def_class_methods_module?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#157
  def in_def_module_function?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#118
  def in_def_sclass?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#110
  def in_defs?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#203
  def instance_variable_call?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#213
  def match_name?(arg_name, method_name); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#185
  def method_definition?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#207
  def module_function_bare_access_modifier?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#176
  def singleton_method_definition?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#194
  def synchronized?(node); end
end

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#65
RuboCop::Cop::ThreadSafety::ClassInstanceVariable::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_instance_variable.rb#66
RuboCop::Cop::ThreadSafety::ClassInstanceVariable::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Avoid using `Dir.chdir` due to its process-wide effect.
# If `AllowCallWithBlock` (disabled by default) option is enabled,
# calling `Dir.chdir` with block will be allowed.
#
# @example
#   # bad
#   Dir.chdir("/var/run")
#
#   # bad
#   FileUtils.chdir("/var/run")
# @example AllowCallWithBlock: false (default)
#   # good
#   Dir.chdir("/var/run") do
#   puts Dir.pwd
#   end
# @example AllowCallWithBlock: true
#   # bad
#   Dir.chdir("/var/run") do
#   puts Dir.pwd
#   end
#
# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/dir_chdir.rb#29
class RuboCop::Cop::ThreadSafety::DirChdir < ::RuboCop::Cop::Base
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/dir_chdir.rb#34
  def chdir?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/dir_chdir.rb#41
  def on_csend(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/dir_chdir.rb#41
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/dir_chdir.rb#59
  def allow_call_with_block?; end
end

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/dir_chdir.rb#30
RuboCop::Cop::ThreadSafety::DirChdir::MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/dir_chdir.rb#31
RuboCop::Cop::ThreadSafety::DirChdir::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks whether some class instance variable isn't a
# mutable literal (e.g. array or hash).
#
# It is based on Style/MutableConstant from RuboCop.
# See https://github.com/rubocop/rubocop/blob/master/lib/rubocop/cop/style/mutable_constant.rb
#
# Class instance variables are a risk to threaded code as they are shared
# between threads. A mutable object such as an array or hash may be
# updated via an attr_reader so would not be detected by the
# ThreadSafety/ClassAndModuleAttributes cop.
#
# Strict mode can be used to freeze all class instance variables, rather
# than just literals.
# Strict mode is considered an experimental feature. It has not been
# updated with an exhaustive list of all methods that will produce frozen
# objects so there is a decent chance of getting some false positives.
# Luckily, there is no harm in freezing an already frozen object.
#
# @example EnforcedStyle: literals (default)
#   # bad
#   class Model
#   @list = [1, 2, 3]
#   end
#
#   # good
#   class Model
#   @list = [1, 2, 3].freeze
#   end
#
#   # good
#   class Model
#   @var = <<~TESTING.freeze
#   This is a heredoc
#   TESTING
#   end
#
#   # good
#   class Model
#   @var = Something.new
#   end
# @example EnforcedStyle: strict
#   # bad
#   class Model
#   @var = Something.new
#   end
#
#   # bad
#   class Model
#   @var = Struct.new do
#   def foo
#   puts 1
#   end
#   end
#   end
#
#   # good
#   class Model
#   @var = Something.new.freeze
#   end
#
#   # good
#   class Model
#   @var = Struct.new do
#   def foo
#   puts 1
#   end
#   end.freeze
#   end
#
# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#75
class RuboCop::Cop::ThreadSafety::MutableClassInstanceVariable < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OperationWithThreadsafeResult
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#112
  def autocorrect(corrector, node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#218
  def define_method?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#213
  def define_singleton_method?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#86
  def on_ivasgn(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#99
  def on_masgn(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#92
  def on_or_asgn(node); end

  # NOTE: Some of these patterns may not actually return an immutable
  # object but we will consider them immutable for this cop.
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#230
  def operation_produces_immutable_object?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#247
  def range_enclosed_in_parentheses?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#223
  def splat_value(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#159
  def check(value); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#178
  def container?(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#204
  def correct_splat_expansion(corrector, expr, splat_value); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#131
  def frozen_string_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#191
  def immutable_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#169
  def in_class?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#185
  def mutable_literal?(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#140
  def on_assignment(value); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#200
  def range_type?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#195
  def requires_parentheses?(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#148
  def strict_check(value); end
end

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#83
RuboCop::Cop::ThreadSafety::MutableClassInstanceVariable::FROZEN_STRING_LITERAL_TYPES_RUBY27 = T.let(T.unsafe(nil), Array)

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#84
RuboCop::Cop::ThreadSafety::MutableClassInstanceVariable::FROZEN_STRING_LITERAL_TYPES_RUBY30 = T.let(T.unsafe(nil), Array)

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#82
RuboCop::Cop::ThreadSafety::MutableClassInstanceVariable::MSG = T.let(T.unsafe(nil), String)

# Avoid starting new threads.
#
# Let a framework like Sidekiq handle the threads.
#
# @example
#   # bad
#   Thread.new { do_work }
#
# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/new_thread.rb#13
class RuboCop::Cop::ThreadSafety::NewThread < ::RuboCop::Cop::Base
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/new_thread.rb#18
  def new_thread?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/new_thread.rb#22
  def on_csend(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/new_thread.rb#22
  def on_send(node); end
end

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/new_thread.rb#14
RuboCop::Cop::ThreadSafety::NewThread::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/new_thread.rb#15
RuboCop::Cop::ThreadSafety::NewThread::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Avoid instance variables in rack middleware.
#
# Middlewares are initialized once, meaning any instance variables are shared between executor threads.
# To avoid potential race conditions, it's recommended to design middlewares to be stateless
# or to implement proper synchronization mechanisms.
#
# @example
#   # bad
#   class CounterMiddleware
#   def initialize(app)
#   @app = app
#   @counter = 0
#   end
#
#   def call(env)
#   app.call(env)
#   ensure
#   @counter += 1
#   end
#   end
#
#   # good
#   class CounterMiddleware
#   def initialize(app)
#   @app = app
#   @counter = Concurrent::AtomicReference.new(0)
#   end
#
#   def call(env)
#   app.call(env)
#   ensure
#   @counter.update { |ref| ref + 1 }
#   end
#   end
#
#   class IdentityMiddleware
#   def initialize(app)
#   @app = app
#   end
#
#   def call(env)
#   app.call(env)
#   end
#   end
#
# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/rack_middleware_instance_variable.rb#50
class RuboCop::Cop::ThreadSafety::RackMiddlewareInstanceVariable < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedIdentifiers
  include ::RuboCop::Cop::OperationWithThreadsafeResult

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/rack_middleware_instance_variable.rb#64
  def app_variable(param0); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/rack_middleware_instance_variable.rb#68
  def on_class(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/rack_middleware_instance_variable.rb#88
  def on_csend(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/rack_middleware_instance_variable.rb#88
  def on_send(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/rack_middleware_instance_variable.rb#59
  def rack_middleware_like_class?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/rack_middleware_instance_variable.rb#106
  def extract_application_variable_from_contructor_method(constructor_method); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/rack_middleware_instance_variable.rb#112
  def extract_safe_variables_from_constructor_method(constructor_method); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/rack_middleware_instance_variable.rb#100
  def find_constructor_method(class_node); end
end

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/rack_middleware_instance_variable.rb#54
RuboCop::Cop::ThreadSafety::RackMiddlewareInstanceVariable::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/rack_middleware_instance_variable.rb#56
RuboCop::Cop::ThreadSafety::RackMiddlewareInstanceVariable::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# RuboCop::ThreadSafety detects some potential thread safety issues.
#
# source://rubocop-thread_safety//lib/rubocop/thread_safety.rb#5
module RuboCop::ThreadSafety; end

# A plugin that integrates RuboCop ThreadSafety with RuboCop's plugin system.
#
# source://rubocop-thread_safety//lib/rubocop/thread_safety/plugin.rb#8
class RuboCop::ThreadSafety::Plugin < ::LintRoller::Plugin
  # :nocov:
  #
  # source://rubocop-thread_safety//lib/rubocop/thread_safety/plugin.rb#10
  def about; end

  # source://rubocop-thread_safety//lib/rubocop/thread_safety/plugin.rb#24
  def rules(_context); end

  # :nocov:
  #
  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/thread_safety/plugin.rb#20
  def supported?(context); end
end

# source://rubocop-thread_safety//lib/rubocop/thread_safety/version.rb#5
module RuboCop::ThreadSafety::Version; end

# source://rubocop-thread_safety//lib/rubocop/thread_safety/version.rb#6
RuboCop::ThreadSafety::Version::STRING = T.let(T.unsafe(nil), String)
