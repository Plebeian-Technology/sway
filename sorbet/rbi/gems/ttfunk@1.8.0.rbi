# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ttfunk` gem.
# Please instead update this file by running `bin/tapioca gem ttfunk`.


# TTFunk is a TrueType and OpenType font library written in pure ruby. It
# supports both parsing and encoding of fonts. Also provides limited font
# subsetting.
#
# It supports a veriety of SFNT-based formats:
# * TrueType fonts (ttf)
# * OpenType fonts (otf), with both TrueType and CFF glyph outlines
# * DFont resources (dfont)
# * TrueType Collections (ttc)
#
# While not all TrueType and OpenType tables are implemented the most common
# ones are.
#
# source://ttfunk//lib/ttfunk/aggregate.rb#3
module TTFunk; end

# Base class for different aggregate values and accumulators.
#
# @see TTFunk::Min
# @see TTFunk::Max
# @see TTFunk::Sum
#
# source://ttfunk//lib/ttfunk/aggregate.rb#9
class TTFunk::Aggregate
  private

  # source://ttfunk//lib/ttfunk/aggregate.rb#12
  def coerce(other); end
end

# Bit crunching utility methods.
#
# source://ttfunk//lib/ttfunk/bin_utils.rb#5
module TTFunk::BinUtils
  extend ::TTFunk::BinUtils

  # Turns a (sorted) sequence of values into a series of two-element arrays
  # where the first element is the start and the second is the length.
  #
  # @param values [Array<Integer>]
  # @return [Array<Array(Integer, Integer)>]
  #
  # source://ttfunk//lib/ttfunk/bin_utils.rb#58
  def rangify(values); end

  # Slice a big integer into a bunch of small integers. Assumes big-endian.
  #
  # @param value [Integer]
  # @param bit_width [Integer] bit width of the elements
  # @param slice_count [Integer] number of elements to slice into. This is
  #   needed for cases where top bits are zero.
  # @return [Array<Integer>]
  #
  # source://ttfunk//lib/ttfunk/bin_utils.rb#28
  def slice_int(value, bit_width:, slice_count:); end

  # Turn a bunch of small integers into one big integer. Assumes big-endian.
  #
  # @param arr [Array<Integer>]
  # @param bit_width [Integer] bit width of the elements
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/bin_utils.rb#11
  def stitch_int(arr, bit_width:); end

  # Two's compliment to an integer.
  #
  # @param num [Integer]
  # @param bit_width [Integer] number width
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/bin_utils.rb#41
  def twos_comp_to_int(num, bit_width:); end
end

# Bitfield represents a series of bits that can individually be toggled.
#
# source://ttfunk//lib/ttfunk/bit_field.rb#5
class TTFunk::BitField
  # @param value [Integer] initial value
  # @return [BitField] a new instance of BitField
  #
  # source://ttfunk//lib/ttfunk/bit_field.rb#11
  def initialize(value = T.unsafe(nil)); end

  # Get a duplicate of this bit field.
  #
  # @return [BitField]
  #
  # source://ttfunk//lib/ttfunk/bit_field.rb#50
  def dup; end

  # Set bit off.
  #
  # @param pos [Integer]
  # @return [void]
  #
  # source://ttfunk//lib/ttfunk/bit_field.rb#35
  def off(pos); end

  # Is bit off?
  #
  # @param pos [Integer]
  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/bit_field.rb#43
  def off?(pos); end

  # Set bit on.
  #
  # @param pos [Integer] bit position
  # @return [void]
  #
  # source://ttfunk//lib/ttfunk/bit_field.rb#19
  def on(pos); end

  # If bit on?
  #
  # @param pos [Integer]
  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/bit_field.rb#27
  def on?(pos); end

  # Serialized value.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/bit_field.rb#8
  def value; end
end

# TrueType font collection. Usually a file with `.ttc` extension.
#
# source://ttfunk//lib/ttfunk/collection.rb#5
class TTFunk::Collection
  include ::Enumerable

  # @param io [IO(#read & #rewind)]
  # @raise [ArgumentError] if `io` doesn't start with a ttc tag
  # @return [Collection] a new instance of Collection
  #
  # source://ttfunk//lib/ttfunk/collection.rb#32
  def initialize(io); end

  # Get font by index.
  #
  # @param index [Integer]
  # @return [TTFunk::File]
  #
  # source://ttfunk//lib/ttfunk/collection.rb#67
  def [](index); end

  # Number of fonts in this collection.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/collection.rb#48
  def count; end

  # Iterate over fonts in the collection.
  #
  # @return [self]
  # @yieldparam font [TTFunk::File]
  #
  # source://ttfunk//lib/ttfunk/collection.rb#56
  def each; end

  class << self
    # Load a TrueType collection.
    #
    # @overload open
    # @overload open
    #
    # source://ttfunk//lib/ttfunk/collection.rb#18
    def open(path); end
  end
end

# SFNT table directory.
#
# source://ttfunk//lib/ttfunk/directory.rb#5
class TTFunk::Directory
  # @return [Directory] a new instance of Directory
  #
  # source://ttfunk//lib/ttfunk/directory.rb#14
  def initialize(io, offset = T.unsafe(nil)); end

  # Scaler type
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/directory.rb#12
  def scaler_type; end

  # Table descriptors
  #
  # @return [Hash{String => Hash}]
  #
  # source://ttfunk//lib/ttfunk/directory.rb#8
  def tables; end
end

# Risen when a placeholder is added to an Encoded String but it already
# contains a placeholder with the same name.
#
# source://ttfunk//lib/ttfunk/encoded_string.rb#14
class TTFunk::DuplicatePlaceholderError < ::StandardError; end

# Encoded string takes care of placeholders in binary strings. Placeholders
# are used when bytes need to be placed in the stream before their value is
# known.
#
# @api private
#
# source://ttfunk//lib/ttfunk/encoded_string.rb#22
class TTFunk::EncodedString
  # @api private
  # @return [EncodedString] a new instance of EncodedString
  # @yieldparam [self]
  #
  # source://ttfunk//lib/ttfunk/encoded_string.rb#24
  def initialize; end

  # Append to string.
  #
  # @api private
  # @param obj [String, Placeholder, EncodedString]
  # @return [self]
  #
  # source://ttfunk//lib/ttfunk/encoded_string.rb#32
  def <<(obj); end

  # Append padding to align string to the specified word width.
  #
  # @api private
  # @param width [Integer]
  # @return [self]
  #
  # source://ttfunk//lib/ttfunk/encoded_string.rb#66
  def align!(width = T.unsafe(nil)); end

  # Raw bytes.
  #
  # @api private
  # @raise [UnresolvedPlaceholderError] if there are any unresolved
  #   placeholders left.
  # @return [Array<Integer>]
  #
  # source://ttfunk//lib/ttfunk/encoded_string.rb#100
  def bytes; end

  # Append multiple objects.
  #
  # @api private
  # @param objs [Array<String, Placeholder, EncodedString>]
  # @return [self]
  #
  # source://ttfunk//lib/ttfunk/encoded_string.rb#55
  def concat(*objs); end

  # Length of this string.
  #
  # @api private
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/encoded_string.rb#77
  def length; end

  # Plaholders
  #
  # @api private
  # @return [Hash{Symbol => Plaholder}]
  #
  # source://ttfunk//lib/ttfunk/encoded_string.rb#131
  def placeholders; end

  # Resolve placeholder.
  #
  # @api private
  # @param name [Symbol]
  # @param value [String]
  # @return [void]
  #
  # source://ttfunk//lib/ttfunk/encoded_string.rb#116
  def resolve_placeholder(name, value); end

  # Raw string.
  #
  # @api private
  # @raise [UnresolvedPlaceholderError] if there are any unresolved
  #   placeholders left.
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/encoded_string.rb#86
  def string; end

  # Unresolved raw string.
  #
  # @api private
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/encoded_string.rb#107
  def unresolved_string; end

  private

  # @api private
  #
  # source://ttfunk//lib/ttfunk/encoded_string.rb#137
  def add_placeholder(new_placeholder, pos = T.unsafe(nil)); end

  # @api private
  #
  # source://ttfunk//lib/ttfunk/encoded_string.rb#147
  def io; end
end

# TTFunk-specific exceptions
#
# source://ttfunk//lib/ttfunk.rb#37
class TTFunk::Error < ::StandardError; end

# File represents an individual font. It can represents both TrueType and
# OpenType fonts.
#
# source://ttfunk//lib/ttfunk.rb#41
class TTFunk::File
  # @param contents [String] binary string containg the font data
  # @param offset [Integer] offset at which the font data starts
  # @return [File] a new instance of File
  #
  # source://ttfunk//lib/ttfunk.rb#148
  def initialize(contents, offset = T.unsafe(nil)); end

  # Glyphs ascent as defined for in the font.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk.rb#156
  def ascent; end

  # Glyps bounding box as defined in the font.
  #
  # @return [Array(Integer, Integer, Integer, Integer)]
  #
  # source://ttfunk//lib/ttfunk.rb#180
  def bbox; end

  # Compact Font Format (`CFF `) table
  #
  # @return [Table::Table::Cff, nil]
  #
  # source://ttfunk//lib/ttfunk.rb#279
  def cff; end

  # Character to Glyph Index Mapping (`cmap`) table
  #
  # @return [TTFunk::Tbale::Cmap, nil]
  #
  # source://ttfunk//lib/ttfunk.rb#202
  def cmap; end

  # Raw content of the font.
  #
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk.rb#44
  def contents; end

  # Glyphs descent as defined in the font.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk.rb#164
  def descent; end

  # Digital Signature (`DSIG`) table
  #
  # @return [TTFunk::Table::Dsig, nil]
  #
  # source://ttfunk//lib/ttfunk.rb#296
  def digital_signature; end

  # Font tables directory.
  #
  # @return [TTFunk::Directory]
  #
  # source://ttfunk//lib/ttfunk.rb#48
  def directory; end

  # Font directory entry for the table with the provided tag.
  #
  # @param tag [String] table tab
  # @return [Hash, nil]
  #
  # source://ttfunk//lib/ttfunk.rb#188
  def directory_info(tag); end

  # Find glyph by its index.
  #
  # @return [TTFunk::Table::Cff::Charstring] if it's a CFF-based OpenType font
  # @return [TTFunk::Table::Glyf::Simple, TTFunk::Table::Glyf::Compound] if it's a TrueType font
  #
  # source://ttfunk//lib/ttfunk.rb#308
  def find_glyph(glyph_id); end

  # Index to Location (`loca`) table
  #
  # @return [TTFunk::Table::Loca, nil]
  #
  # source://ttfunk//lib/ttfunk.rb#258
  def glyph_locations; end

  # Glyph Data (`glyf`) table
  #
  # @return [TTFunk::Table::Glyf, nil]
  #
  # source://ttfunk//lib/ttfunk.rb#265
  def glyph_outlines; end

  # Font Header (`head`) table
  #
  # @return [TTFunk::Table::Head, nil]
  #
  # source://ttfunk//lib/ttfunk.rb#195
  def header; end

  # Horizontal Header (`hhea`) table
  #
  # @return [TTFunk::Table::Hhea, nil]
  #
  # source://ttfunk//lib/ttfunk.rb#209
  def horizontal_header; end

  # Horizontal Metrics (`hmtx`) table
  #
  # @return [TTFunk::Table::Hmtx, nil]
  #
  # source://ttfunk//lib/ttfunk.rb#216
  def horizontal_metrics; end

  # Kerning (`kern`) table
  #
  # @return [TTFunk::Table::Kern, nil]
  #
  # source://ttfunk//lib/ttfunk.rb#230
  def kerning; end

  # Line gap as defined in the font.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk.rb#172
  def line_gap; end

  # Maximum Profile (`maxp`) table
  #
  # @return [TTFunk::Table::Maxp, nil]
  #
  # source://ttfunk//lib/ttfunk.rb#223
  def maximum_profile; end

  # Naming (`name`) table
  #
  # @return [TTFunk::Table::Name, nil]
  #
  # source://ttfunk//lib/ttfunk.rb#237
  def name; end

  # OS/2 and Windows Metrics (`OS/2`) table
  #
  # @return [TTFunk::Table:OS2, nil]
  #
  # source://ttfunk//lib/ttfunk.rb#244
  def os2; end

  # PostScript (`post`) table
  #
  # @return [TTFunk::Table::Post, nil]
  #
  # source://ttfunk//lib/ttfunk.rb#251
  def postscript; end

  # Standard Bitmap Graphics (`sbix`) table
  #
  # @return [TTFunk::Table::Sbix, nil]
  #
  # source://ttfunk//lib/ttfunk.rb#272
  def sbix; end

  # Vertical Origin (`VORG`) table
  #
  # @return [TTFunk::Table::Vorg, nil]
  #
  # source://ttfunk//lib/ttfunk.rb#286
  def vertical_origins; end

  class << self
    # Load a font from a resource file.
    #
    # @param file [String, Pathname] Path to the resource file.
    # @param which [Integer, String] index or name of the font to load
    # @return [TTFunk::File] ]
    #
    # source://ttfunk//lib/ttfunk.rb#68
    def from_dfont(file, which = T.unsafe(nil)); end

    # Load a font from a TrueType collection.
    #
    # @overload from_ttc
    # @overload from_ttc
    #
    # source://ttfunk//lib/ttfunk.rb#82
    def from_ttc(file, which = T.unsafe(nil)); end

    # Open font file
    #
    # @overload open
    # @overload open
    #
    # source://ttfunk//lib/ttfunk.rb#59
    def open(io_or_path); end

    # Turn a path or IO into an IO convenient for TTFunk. The resulting IO is
    # going to be in bin mode and its position set to the beginning.
    #
    # @deprecated This method might retain open files for longer than necessary.
    # @overload verify_and_open
    # @overload verify_and_open
    # @raise [ArgumentError]
    # @see .verify_and_read
    #
    # source://ttfunk//lib/ttfunk.rb#98
    def verify_and_open(io_or_path); end

    # Read contents of a path or IO.
    #
    # @overload verify_and_read
    # @overload verify_and_read
    # @raise [ArgumentError]
    #
    # source://ttfunk//lib/ttfunk.rb#127
    def verify_and_read(io_or_path); end
  end
end

# Maximum aggregate. Its value can only become greater.
#
# source://ttfunk//lib/ttfunk/max.rb#5
class TTFunk::Max < ::TTFunk::Aggregate
  # @param init_value [Comparable] initial value
  # @return [Max] a new instance of Max
  #
  # source://ttfunk//lib/ttfunk/max.rb#12
  def initialize(init_value = T.unsafe(nil)); end

  # Push a value. It will become the new value if it's greater than the
  # current value (or if there was no value).
  #
  # @param new_value [Comparable]
  # @return [void]
  #
  # source://ttfunk//lib/ttfunk/max.rb#22
  def <<(new_value); end

  # Value
  #
  # @return [Comparable, nil]
  #
  # source://ttfunk//lib/ttfunk/max.rb#9
  def value; end

  # Get the stored value or default.
  #
  # @param default [any]
  # @return [any]
  #
  # source://ttfunk//lib/ttfunk/max.rb#34
  def value_or(default); end
end

# Minimum aggregate. Its value can only become lower.
#
# source://ttfunk//lib/ttfunk/min.rb#5
class TTFunk::Min < ::TTFunk::Aggregate
  # @param init_value [Comparable] initial value
  # @return [Min] a new instance of Min
  #
  # source://ttfunk//lib/ttfunk/min.rb#12
  def initialize(init_value = T.unsafe(nil)); end

  # Push a value. It will become the new value if it's lower than the current
  # value (or if there was no value).
  #
  # @param new_value [Comparable]
  # @return [void]
  #
  # source://ttfunk//lib/ttfunk/min.rb#22
  def <<(new_value); end

  # Value
  #
  # @return [Comparable, nil]
  #
  # source://ttfunk//lib/ttfunk/min.rb#9
  def value; end

  # Get the stored value or default.
  #
  # @param default [any]
  # @return [any]
  #
  # source://ttfunk//lib/ttfunk/min.rb#34
  def value_or(default); end
end

# Encodes a CFF-based OpenType font subset to its binary representation.
#
# source://ttfunk//lib/ttfunk/otf_encoder.rb#5
class TTFunk::OTFEncoder < ::TTFunk::TTFEncoder
  private

  # source://ttfunk//lib/ttfunk/otf_encoder.rb#25
  def base_table; end

  # source://ttfunk//lib/ttfunk/otf_encoder.rb#29
  def cff_table; end

  # CFF fonts don't maintain a glyf table, all glyph information is stored
  # in the charstrings index. Return an empty hash here to indicate a glyf
  # table should not be encoded.
  #
  # source://ttfunk//lib/ttfunk/otf_encoder.rb#14
  def glyf_table; end

  # Since CFF fonts don't maintain a glyf table, they also don't maintain
  # a loca table. Return an empty hash here to indicate a loca table
  # shouldn't be encoded.
  #
  # source://ttfunk//lib/ttfunk/otf_encoder.rb#21
  def loca_table; end

  # source://ttfunk//lib/ttfunk/otf_encoder.rb#45
  def optimal_table_order; end

  # source://ttfunk//lib/ttfunk/otf_encoder.rb#37
  def tables; end

  # source://ttfunk//lib/ttfunk/otf_encoder.rb#33
  def vorg_table; end
end

# Optimal table order according to OpenType specification.
#
# source://ttfunk//lib/ttfunk/otf_encoder.rb#7
TTFunk::OTFEncoder::OPTIMAL_TABLE_ORDER = T.let(T.unsafe(nil), Array)

# Array with indexing starting at 1.
#
# source://ttfunk//lib/ttfunk/one_based_array.rb#5
class TTFunk::OneBasedArray
  include ::Enumerable

  # @overload initialize
  # @overload initialize
  # @return [OneBasedArray] a new instance of OneBasedArray
  #
  # source://ttfunk//lib/ttfunk/one_based_array.rb#12
  def initialize(size = T.unsafe(nil)); end

  # Get element by index.
  #
  # @param idx [Integer]
  # @raise IndexError if index is 0
  # @return [any, nil]
  #
  # source://ttfunk//lib/ttfunk/one_based_array.rb#21
  def [](idx); end

  # Iterate over elements.
  #
  # @return [void]
  # @yieldparam element [any]
  #
  # source://ttfunk//lib/ttfunk/one_based_array.rb#48
  def each(&block); end

  # Number of elements in this array.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/one_based_array.rb#33
  def size; end

  # Convert to native array.
  #
  # @return [Array]
  #
  # source://ttfunk//lib/ttfunk/one_based_array.rb#40
  def to_ary; end

  private

  # Returns the value of attribute entries.
  #
  # source://ttfunk//lib/ttfunk/one_based_array.rb#54
  def entries; end
end

# Encoded String placeholder.
#
# @api private
#
# source://ttfunk//lib/ttfunk/placeholder.rb#7
class TTFunk::Placeholder
  # @api private
  # @param name [Symbol]
  # @param length [Integer]
  # @return [Placeholder] a new instance of Placeholder
  #
  # source://ttfunk//lib/ttfunk/placeholder.rb#22
  def initialize(name, length: T.unsafe(nil)); end

  # Length of the placeholder
  #
  # @api private
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/placeholder.rb#18
  def length; end

  # Planceholder name
  #
  # @api private
  # @return [Symbol]
  #
  # source://ttfunk//lib/ttfunk/placeholder.rb#14
  def name; end

  # Placeholder position in the cintaining Encoded String
  #
  # @api private
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/placeholder.rb#10
  def position; end

  # Placeholder position in the cintaining Encoded String
  #
  # @api private
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/placeholder.rb#10
  def position=(_arg0); end
end

# Helper methods to read form file content.
#
# @api rpivate
#
# source://ttfunk//lib/ttfunk/reader.rb#6
module TTFunk::Reader
  private

  # For debugging purposes
  #
  # @api rpivate
  #
  # source://ttfunk//lib/ttfunk/reader.rb#34
  def hexdump(string); end

  # @api rpivate
  #
  # source://ttfunk//lib/ttfunk/reader.rb#9
  def io; end

  # @api rpivate
  #
  # source://ttfunk//lib/ttfunk/reader.rb#25
  def parse_from(position); end

  # @api rpivate
  #
  # source://ttfunk//lib/ttfunk/reader.rb#13
  def read(bytes, format); end

  # @api rpivate
  #
  # source://ttfunk//lib/ttfunk/reader.rb#17
  def read_signed(count); end

  # @api rpivate
  #
  # source://ttfunk//lib/ttfunk/reader.rb#21
  def to_signed(number); end
end

# Data-fork suitcases resource file
#
# source://ttfunk//lib/ttfunk/resource_file.rb#5
class TTFunk::ResourceFile
  # @param io [IO]
  # @return [ResourceFile] a new instance of ResourceFile
  #
  # source://ttfunk//lib/ttfunk/resource_file.rb#24
  def initialize(io); end

  # Get resource
  #
  # @overload []
  # @overload []
  #
  # source://ttfunk//lib/ttfunk/resource_file.rb#81
  def [](type, index = T.unsafe(nil)); end

  # Resource map
  #
  # @return [Hash]
  #
  # source://ttfunk//lib/ttfunk/resource_file.rb#9
  def map; end

  # Get resource names
  #
  # @param type [String]
  # @return [Array<String>]
  #
  # source://ttfunk//lib/ttfunk/resource_file.rb#97
  def resources_for(type); end

  private

  # source://ttfunk//lib/ttfunk/resource_file.rb#103
  def parse_from(offset); end

  class << self
    # Open a resource file
    #
    # @param path [String, Pathname]
    # @return [any] result of the block
    # @yieldparam resource_file [TTFunk::ResourceFile]
    #
    # source://ttfunk//lib/ttfunk/resource_file.rb#16
    def open(path); end
  end
end

# Scientific number representation
#
# source://ttfunk//lib/ttfunk/sci_form.rb#5
class TTFunk::SciForm
  # @param significand [Float, Integer]
  # @param exponent [Float, Integer]
  # @return [SciForm] a new instance of SciForm
  #
  # source://ttfunk//lib/ttfunk/sci_form.rb#16
  def initialize(significand, exponent = T.unsafe(nil)); end

  # Check equality to another number.
  #
  # @param other [Float, SciForm]
  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/sci_form.rb#32
  def ==(other); end

  # Check equality to another number.
  #
  # @param other [Float, SciForm]
  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/sci_form.rb#32
  def eql?(other); end

  # Exponent
  #
  # @return [Float, Integer]
  #
  # source://ttfunk//lib/ttfunk/sci_form.rb#12
  def exponent; end

  # Significand
  #
  # @return [Float, Integer]
  #
  # source://ttfunk//lib/ttfunk/sci_form.rb#8
  def significand; end

  # Convert to Float.
  #
  # @return [Float]
  #
  # source://ttfunk//lib/ttfunk/sci_form.rb#24
  def to_f; end
end

# SFNT sub-table
#
# source://ttfunk//lib/ttfunk/sub_table.rb#7
class TTFunk::SubTable
  include ::TTFunk::Reader

  # @param file [IO]
  # @param offset [Integer]
  # @param length [Integer]
  # @return [SubTable] a new instance of SubTable
  #
  # source://ttfunk//lib/ttfunk/sub_table.rb#29
  def initialize(file, offset, length = T.unsafe(nil)); end

  # End of sub-table?
  #
  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/sub_table.rb#39
  def eot?; end

  # File or IO this sub-table is in.
  #
  # @return [IO]
  #
  # source://ttfunk//lib/ttfunk/sub_table.rb#16
  def file; end

  # This sub-table's length in byes.
  #
  # @return [Integer, nil]
  #
  # source://ttfunk//lib/ttfunk/sub_table.rb#24
  def length; end

  # Read a series of values.
  #
  # @overload read
  #
  # source://ttfunk//lib/ttfunk/sub_table.rb#55
  def read(*args); end

  # This sub-table's offset from the file beginning.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/sub_table.rb#20
  def table_offset; end
end

# A read past sub-table end was attempted.
#
# source://ttfunk//lib/ttfunk/sub_table.rb#9
class TTFunk::SubTable::EOTError < ::StandardError; end

# Sum aggreaget. Is sums all pushed values.
#
# source://ttfunk//lib/ttfunk/sum.rb#5
class TTFunk::Sum < ::TTFunk::Aggregate
  # @param init_value [#+] initial value
  # @return [Sum] a new instance of Sum
  #
  # source://ttfunk//lib/ttfunk/sum.rb#12
  def initialize(init_value = T.unsafe(nil)); end

  # Push a value. It will be added to the current value.
  #
  # @param operand [any]
  # @return [void]
  #
  # source://ttfunk//lib/ttfunk/sum.rb#21
  def <<(operand); end

  # Value
  #
  # @return [#+]
  #
  # source://ttfunk//lib/ttfunk/sum.rb#9
  def value; end

  # Get the stored value or default.
  #
  # @param _default [any] Unused. Here for API compatibility.
  # @return [any]
  #
  # source://ttfunk//lib/ttfunk/sum.rb#29
  def value_or(_default); end
end

# Encodes a TrueType font subset to its binary representation.
#
# source://ttfunk//lib/ttfunk/ttf_encoder.rb#5
class TTFunk::TTFEncoder
  # @option options
  # @param original [TTFunk::File]
  # @param subset [TTFunk::Subset]
  # @param options [Hash]
  # @return [TTFEncoder] a new instance of TTFEncoder
  #
  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#30
  def initialize(original, subset, options = T.unsafe(nil)); end

  # Encode the font subset.
  #
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#39
  def encode; end

  # Encoding options.
  #
  # @return [Hash]
  #
  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#23
  def options; end

  # Original font.
  #
  # @return [TTFunk::File]
  #
  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#15
  def original; end

  # Subset to encode.
  #
  # @return [TTFunk::Subset]
  #
  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#19
  def subset; end

  private

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#210
  def align(data, width); end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#202
  def checksum(data); end

  # "mandatory" tables. Every font should ("should") have these
  #
  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#89
  def cmap_table; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#133
  def cvt_table; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#164
  def dsig_table; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#137
  def fpgm_table; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#145
  def gasp_table; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#93
  def glyf_table; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#190
  def glyphs; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#121
  def head_table; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#105
  def hhea_table; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#101
  def hmtx_table; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#149
  def kern_table; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#97
  def loca_table; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#109
  def maxp_table; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#117
  def name_table; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#194
  def new_to_old_glyph; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#198
  def old_to_new_glyph; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#81
  def optimal_table_order; end

  # "optional" tables. Fonts may omit these if they do not need them.
  # Because they apply globally, we can simply copy them over, without
  # modification, if they exist.
  #
  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#129
  def os2_table; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#113
  def post_table; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#141
  def prep_table; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#206
  def raw(data); end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#168
  def tables; end

  # source://ttfunk//lib/ttfunk/ttf_encoder.rb#160
  def vorg_table; end
end

# Optimal table order according to TrueType specification.
#
# source://ttfunk//lib/ttfunk/ttf_encoder.rb#7
TTFunk::TTFEncoder::OPTIMAL_TABLE_ORDER = T.let(T.unsafe(nil), Array)

# SFNT table
#
# source://ttfunk//lib/ttfunk/table/cff.rb#4
class TTFunk::Table
  include ::TTFunk::Reader

  # @param file [TTFunk::File]
  # @return [Table] a new instance of Table
  #
  # source://ttfunk//lib/ttfunk/table.rb#23
  def initialize(file); end

  # Does this table exist in the file?
  #
  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/table.rb#41
  def exists?; end

  # File this table is in.
  #
  # @return [TTFunk::File]
  #
  # source://ttfunk//lib/ttfunk/table.rb#12
  def file; end

  # This table's length in byes.
  #
  # @return [Integer, nil]
  #
  # source://ttfunk//lib/ttfunk/table.rb#20
  def length; end

  # This table's offset from the file beginning.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table.rb#16
  def offset; end

  # Raw bytes of this table in the file.
  #
  # @return [String, nil]
  #
  # source://ttfunk//lib/ttfunk/table.rb#48
  def raw; end

  # Table tag.
  #
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table.rb#57
  def tag; end

  private

  # source://ttfunk//lib/ttfunk/table.rb#63
  def parse!; end
end

# Compact Font Format (`CFF `) table
#
# source://ttfunk//lib/ttfunk/table/cff.rb#6
class TTFunk::Table::Cff < ::TTFunk::Table
  # Encode table.
  #
  # @param subset [TTFunk::Subset::MacRoman, TTFunk::Subset::Windows1252, TTFunk::Subset::Unicode, TTFunk::Subset::Unicode8Bit]
  # @return [TTFunk::EncodedString]
  #
  # source://ttfunk//lib/ttfunk/table/cff.rb#60
  def encode(subset); end

  # Global subroutine index.
  #
  # @return [TTFunk::Table::Cff::SubrIndex]
  #
  # source://ttfunk//lib/ttfunk/table/cff.rb#47
  def global_subr_index; end

  # Table header.
  #
  # @return [TTFunk::Table::Cff::Header]
  #
  # source://ttfunk//lib/ttfunk/table/cff.rb#31
  def header; end

  # Name index.
  #
  # @return [TTFunk::Table::Cff::Index]
  #
  # source://ttfunk//lib/ttfunk/table/cff.rb#35
  def name_index; end

  # Strings index.
  #
  # @return [TTFunk::Table::Cff::OneBasedIndex]
  #
  # source://ttfunk//lib/ttfunk/table/cff.rb#43
  def string_index; end

  # Table tag.
  #
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/cff.rb#51
  def tag; end

  # Top dict index.
  #
  # @return [TTFunk::Table::Cff::TopIndex]
  #
  # source://ttfunk//lib/ttfunk/table/cff.rb#39
  def top_index; end

  private

  # source://ttfunk//lib/ttfunk/table/cff.rb#80
  def parse!; end
end

# CFF Charset
#
# source://ttfunk//lib/ttfunk/table/cff/charset.rb#7
class TTFunk::Table::Cff::Charset < ::TTFunk::SubTable
  include ::Enumerable

  # @overload initialize
  # @overload initialize
  # @return [Charset] a new instance of Charset
  #
  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#92
  def initialize(top_dict, file, offset_or_id = T.unsafe(nil), length = T.unsafe(nil)); end

  # Get character name for glyph index.
  #
  # @param glyph_id [Integer]
  # @return [String, nil]
  #
  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#121
  def [](glyph_id); end

  # Iterate over character names.
  #
  # @overload each
  # @overload each
  #
  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#110
  def each; end

  # Encode charset.
  #
  # @param charmap [Hash{Integer => Hash}] keys are the charac codes,
  #   values are hashes:
  #   * `:old` (<tt>Integer</tt>) - glyph ID in the original font.
  #   * `:new` (<tt>Integer</tt>) - glyph ID in the subset font.
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#149
  def encode(charmap); end

  # Encoded entries.
  #
  # @return [TTFunk::OneBasedArray<Integer>, Array<Range<Integer>>]
  #
  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#61
  def entries; end

  # Encodign format.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#73
  def format; end

  # Number of encoded items.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#77
  def items_count; end

  # Length of encoded charset subtable.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#65
  def length; end

  # Charset offset in the file.
  #
  # @return [Integer, nil]
  #
  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#130
  def offset; end

  # Offset or charset ID.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#81
  def offset_or_id; end

  # Top dict.
  #
  # @return [TTFunk::Table::Cff::TopDict]
  #
  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#69
  def top_dict; end

  private

  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#263
  def element_format(fmt = T.unsafe(nil)); end

  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#255
  def element_width(fmt = T.unsafe(nil)); end

  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#213
  def find_string(sid); end

  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#281
  def format_int(sym = T.unsafe(nil)); end

  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#271
  def format_sym; end

  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#227
  def parse!; end

  # source://ttfunk//lib/ttfunk/table/cff/charset.rb#191
  def sid_for(glyph_id); end

  class << self
    # Standard strings defined in the spec that do not need to be defined
    # in the CFF.
    #
    # @return [TTFunk::OneBasedArray<String>]
    #
    # source://ttfunk//lib/ttfunk/table/cff/charset.rb#39
    def standard_strings; end

    # Strings for charset ID.
    #
    # @param charset_id [Integer]
    # @return [TTFunk::OneBasedArray<String>]
    #
    # source://ttfunk//lib/ttfunk/table/cff/charset.rb#47
    def strings_for_charset_id(charset_id); end
  end
end

# Format 0.
#
# source://ttfunk//lib/ttfunk/table/cff/charset.rb#14
TTFunk::Table::Cff::Charset::ARRAY_FORMAT = T.let(T.unsafe(nil), Integer)

# Default charset ID.
#
# source://ttfunk//lib/ttfunk/table/cff/charset.rb#32
TTFunk::Table::Cff::Charset::DEFAULT_CHARSET_ID = T.let(T.unsafe(nil), Integer)

# Predefined Expert charset ID.
#
# source://ttfunk//lib/ttfunk/table/cff/charset.rb#26
TTFunk::Table::Cff::Charset::EXPERT_CHARSET_ID = T.let(T.unsafe(nil), Integer)

# Predefined Expert Subset charset ID.
#
# source://ttfunk//lib/ttfunk/table/cff/charset.rb#29
TTFunk::Table::Cff::Charset::EXPERT_SUBSET_CHARSET_ID = T.let(T.unsafe(nil), Integer)

# First glyph string. This is an implicit glyph present in all charsets.
#
# source://ttfunk//lib/ttfunk/table/cff/charset.rb#11
TTFunk::Table::Cff::Charset::FIRST_GLYPH_STRING = T.let(T.unsafe(nil), String)

# Predefined ISOAdobe charset ID.
#
# source://ttfunk//lib/ttfunk/table/cff/charset.rb#23
TTFunk::Table::Cff::Charset::ISO_ADOBE_CHARSET_ID = T.let(T.unsafe(nil), Integer)

# Format 2.
#
# source://ttfunk//lib/ttfunk/table/cff/charset.rb#20
TTFunk::Table::Cff::Charset::RANGE_FORMAT_16 = T.let(T.unsafe(nil), Integer)

# Format 1.
#
# source://ttfunk//lib/ttfunk/table/cff/charset.rb#17
TTFunk::Table::Cff::Charset::RANGE_FORMAT_8 = T.let(T.unsafe(nil), Integer)

# Predefined CFF data
#
# source://ttfunk//lib/ttfunk/table/cff/charsets.rb#7
module TTFunk::Table::Cff::Charsets; end

# Predefinde CFF Expert charset
#
# source://ttfunk//lib/ttfunk/table/cff/charsets/expert.rb#8
TTFunk::Table::Cff::Charsets::EXPERT = T.let(T.unsafe(nil), TTFunk::OneBasedArray)

# Predefined CFF Expert Subset charset
#
# source://ttfunk//lib/ttfunk/table/cff/charsets/expert_subset.rb#8
TTFunk::Table::Cff::Charsets::EXPERT_SUBSET = T.let(T.unsafe(nil), TTFunk::OneBasedArray)

# Predefined CFF ISOAdobe charset
#
# source://ttfunk//lib/ttfunk/table/cff/charsets/iso_adobe.rb#8
TTFunk::Table::Cff::Charsets::ISO_ADOBE = T.let(T.unsafe(nil), TTFunk::OneBasedArray)

# Standard CFF strings
#
# source://ttfunk//lib/ttfunk/table/cff/charsets/standard_strings.rb#8
TTFunk::Table::Cff::Charsets::STANDARD_STRINGS = T.let(T.unsafe(nil), TTFunk::OneBasedArray)

# CFF Charstring.
#
# source://ttfunk//lib/ttfunk/table/cff/charstring.rb#7
class TTFunk::Table::Cff::Charstring
  # @param glyph_id [Integer]
  # @param top_dict [TTFunk::Table:Cff::TopDict]
  # @param font_dict [TTFunk::Table:Cff::FontDict]
  # @param raw [String]
  # @return [Charstring] a new instance of Charstring
  #
  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#56
  def initialize(glyph_id, top_dict, font_dict, raw); end

  # Get a TrueType-compatible glyph representation of this charstring.
  #
  # @return [TTFunk::Table::Glyf::PathBased]
  #
  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#96
  def glyph; end

  # Glyph ID.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#46
  def glyph_id; end

  # Get path representation of this charstring.
  #
  # @return [TTFunk::Table::Cff::Path]
  #
  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#85
  def path; end

  # Encoded charstring.
  #
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#50
  def raw; end

  # Get path representation of this charstring at the specified font size.
  #
  # @param x [Integer, Float] new horizontal position.
  # @param y [Integer, Float] new vertical position.
  # @param font_size [Integer, Float] font size.
  # @return [TTFunk::Table::Cff::Path]
  #
  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#110
  def render(x: T.unsafe(nil), y: T.unsafe(nil), font_size: T.unsafe(nil)); end

  private

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#190
  def add_contour(x, y); end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#455
  def callgsubr; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#243
  def callsubr; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#350
  def cntrmask; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#330
  def endchar; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#255
  def flex; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#308
  def flex1; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#249
  def flex_select; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#274
  def hflex; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#291
  def hflex1; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#433
  def hhcurveto; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#346
  def hintmask; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#207
  def hlineto; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#369
  def hmoveto; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#156
  def hstem; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#342
  def hstemhm; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#483
  def hvcurveto; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#121
  def parse!; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#383
  def rcurveline; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#150
  def read_bytes(length); end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#399
  def rlinecurve; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#199
  def rlineto; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#358
  def rmoveto; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#231
  def rrcurveto; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#450
  def shortint; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#165
  def stem; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#461
  def vhcurveto; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#219
  def vlineto; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#180
  def vmoveto; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#160
  def vstem; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#379
  def vstemhm; end

  # source://ttfunk//lib/ttfunk/table/cff/charstring.rb#417
  def vvcurveto; end
end

# Type 2 charstring operators
#
# source://ttfunk//lib/ttfunk/table/cff/charstring.rb#9
TTFunk::Table::Cff::Charstring::CODE_MAP = T.let(T.unsafe(nil), Hash)

# Type 2 Flex operators.
#
# source://ttfunk//lib/ttfunk/table/cff/charstring.rb#37
TTFunk::Table::Cff::Charstring::FLEX_CODE_MAP = T.let(T.unsafe(nil), Hash)

# CFF Charstrings Index.
#
# source://ttfunk//lib/ttfunk/table/cff/charstrings_index.rb#7
class TTFunk::Table::Cff::CharstringsIndex < ::TTFunk::Table::Cff::Index
  # @overload initialize
  # @return [CharstringsIndex] a new instance of CharstringsIndex
  #
  # source://ttfunk//lib/ttfunk/table/cff/charstrings_index.rb#17
  def initialize(top_dict, *remaining_args); end

  # Top dict.
  #
  # @return [TTFunk::Table::Cff::TopDict]
  #
  # source://ttfunk//lib/ttfunk/table/cff/charstrings_index.rb#10
  def top_dict; end

  private

  # source://ttfunk//lib/ttfunk/table/cff/charstrings_index.rb#24
  def decode_item(index, _offset, _length); end

  # source://ttfunk//lib/ttfunk/table/cff/charstrings_index.rb#28
  def encode_items(charmap); end

  # source://ttfunk//lib/ttfunk/table/cff/charstrings_index.rb#35
  def font_dict_for(index); end
end

# CFF Dict.
#
# source://ttfunk//lib/ttfunk/table/cff/dict.rb#9
class TTFunk::Table::Cff::Dict < ::TTFunk::SubTable
  include ::Enumerable

  # Get dict value by operator.
  #
  # @param operator [Integer]
  # @return [Array<Integer, TTFunk::SciForm>]
  #
  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#43
  def [](operator); end

  # Add dict entry.
  #
  # @param operator [Integer] Entry operator. Must be in range 0..255. Wide operators must be in range 1200..1455.
  # @param operands [Array<Integer, TTFunk::SciForm>]
  #
  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#51
  def []=(operator, *operands); end

  # Iterate over dict entries.
  #
  # @return [void]
  # @yieldparam key [Integer]
  # @yieldparam value [Array<Integer, TTFunk::SciForm>]
  #
  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#60
  def each(&block); end

  # Iterate over dict entries.
  #
  # @return [void]
  # @yieldparam key [Integer]
  # @yieldparam value [Array<Integer, TTFunk::SciForm>]
  #
  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#60
  def each_pair(&block); end

  # Encode dict.
  #
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#69
  def encode; end

  private

  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#268
  def decode_integer(b_zero); end

  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#202
  def decode_operand(b_zero); end

  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#211
  def decode_sci; end

  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#198
  def decode_wide_operator; end

  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#137
  def encode_exponent(exp); end

  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#127
  def encode_float(float); end

  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#102
  def encode_integer(int); end

  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#123
  def encode_integer32(int); end

  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#91
  def encode_operand(operand); end

  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#80
  def encode_operator(operator); end

  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#131
  def encode_sci(sci); end

  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#143
  def encode_significand(sig); end

  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#158
  def pack_decimal_nibbles(nibbles); end

  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#171
  def parse!; end

  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#261
  def valid_exponent?(exponent); end

  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#257
  def valid_significand?(significand); end

  # source://ttfunk//lib/ttfunk/table/cff/dict.rb#248
  def validate_sci!(significand, exponent); end
end

# Indicates malformed operand.
#
# source://ttfunk//lib/ttfunk/table/cff/dict.rb#11
class TTFunk::Table::Cff::Dict::InvalidOperandError < ::StandardError; end

# Maximum number of operands allowed per operator.
#
# source://ttfunk//lib/ttfunk/table/cff/dict.rb#28
TTFunk::Table::Cff::Dict::MAX_OPERANDS = T.let(T.unsafe(nil), Integer)

# Bytes indicating an operand.
#
# source://ttfunk//lib/ttfunk/table/cff/dict.rb#19
TTFunk::Table::Cff::Dict::OPERAND_BZERO = T.let(T.unsafe(nil), Array)

# Single-byte operators.
#
# source://ttfunk//lib/ttfunk/table/cff/dict.rb#17
TTFunk::Table::Cff::Dict::OPERATOR_BZERO = T.let(T.unsafe(nil), Range)

# Indicates too many operands.
#
# source://ttfunk//lib/ttfunk/table/cff/dict.rb#14
class TTFunk::Table::Cff::Dict::TooManyOperandsError < ::StandardError; end

# Scientific notation operand exponent validation regular experession.
#
# source://ttfunk//lib/ttfunk/table/cff/dict.rb#35
TTFunk::Table::Cff::Dict::VALID_SCI_EXPONENT_RE = T.let(T.unsafe(nil), Regexp)

# Scientific notation operand significand validation regular
# experession.
#
# source://ttfunk//lib/ttfunk/table/cff/dict.rb#32
TTFunk::Table::Cff::Dict::VALID_SCI_SIGNIFICAND_RE = T.let(T.unsafe(nil), Regexp)

# Two-byte operator adjustment. Used for encoding and decoding of wide
# operators.
#
# source://ttfunk//lib/ttfunk/table/cff/dict.rb#25
TTFunk::Table::Cff::Dict::WIDE_OPERATOR_ADJUSTMENT = T.let(T.unsafe(nil), Integer)

# Two-byte operator
#
# source://ttfunk//lib/ttfunk/table/cff/dict.rb#22
TTFunk::Table::Cff::Dict::WIDE_OPERATOR_BZERO = T.let(T.unsafe(nil), Integer)

# CFF Encoding.
#
# source://ttfunk//lib/ttfunk/table/cff/encoding.rb#7
class TTFunk::Table::Cff::Encoding < ::TTFunk::SubTable
  include ::Enumerable

  # @overload initialize
  # @overload initialize
  # @return [Encoding] a new instance of Encoding
  #
  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#59
  def initialize(top_dict, file, offset_or_id = T.unsafe(nil), length = T.unsafe(nil)); end

  # Get character code for glyph index.
  #
  # @param glyph_id [Integer]
  # @return [Integer, nil]
  #
  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#90
  def [](glyph_id); end

  # Iterate over character codes.
  #
  # @overload each
  # @overload each
  #
  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#79
  def each; end

  # Encode encoding.
  #
  # @param charmap [Hash{Integer => Hash}] keys are the charac codes,
  #   values are hashes:
  #   * `:old` (<tt>Integer</tt>) - glyph ID in the original font.
  #   * `:new` (<tt>Integer</tt>) - glyph ID in the subset font.
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#120
  def encode(charmap); end

  # Encodign format.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#40
  def format; end

  # Number of encoded items.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#44
  def items_count; end

  # Encoding offset in the file.
  #
  # @return [Integer, nil]
  #
  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#100
  def offset; end

  # Offset or encoding ID.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#48
  def offset_or_id; end

  # Is this a supplemental encoding?
  #
  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#156
  def supplemental?; end

  # Top dict.
  #
  # @return [TTFunk::Table::Cff::TopDict]
  #
  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#36
  def top_dict; end

  private

  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#179
  def code_for(glyph_id); end

  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#235
  def element_format(fmt = T.unsafe(nil)); end

  # @TODO: handle supplemental encoding (necessary?)
  #
  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#244
  def element_width(fmt = T.unsafe(nil)); end

  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#163
  def encode_supplemental(charmap); end

  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#265
  def format_int(sym = T.unsafe(nil)); end

  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#254
  def format_sym; end

  # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#205
  def parse!; end

  class << self
    # Get predefined encoding by ID.
    #
    # @param encoding_id [Integer]
    # @return [TTFunk::OneBasedArray<Integer>]
    #
    # source://ttfunk//lib/ttfunk/table/cff/encoding.rb#24
    def codes_for_encoding_id(encoding_id); end
  end
end

# Default encoding ID.
#
# source://ttfunk//lib/ttfunk/table/cff/encoding.rb#17
TTFunk::Table::Cff::Encoding::DEFAULT_ENCODING_ID = T.let(T.unsafe(nil), Integer)

# Predefined Expert Encoding ID.
#
# source://ttfunk//lib/ttfunk/table/cff/encoding.rb#14
TTFunk::Table::Cff::Encoding::EXPERT_ENCODING_ID = T.let(T.unsafe(nil), Integer)

# Predefined Standard Encoding ID.
#
# source://ttfunk//lib/ttfunk/table/cff/encoding.rb#11
TTFunk::Table::Cff::Encoding::STANDARD_ENCODING_ID = T.let(T.unsafe(nil), Integer)

# Predefined encodings.
#
# source://ttfunk//lib/ttfunk/table/cff/encodings.rb#7
module TTFunk::Table::Cff::Encodings; end

# CFF predefined Expert encoding.
#
# source://ttfunk//lib/ttfunk/table/cff/encodings/expert.rb#8
TTFunk::Table::Cff::Encodings::EXPERT = T.let(T.unsafe(nil), TTFunk::OneBasedArray)

# CFF predefined Standard encoding.
#
# source://ttfunk//lib/ttfunk/table/cff/encodings/standard.rb#8
TTFunk::Table::Cff::Encodings::STANDARD = T.let(T.unsafe(nil), TTFunk::OneBasedArray)

# CFF FDSelect.
#
# source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#7
class TTFunk::Table::Cff::FdSelector < ::TTFunk::SubTable
  include ::Enumerable

  # @param top_dict [TTFunk::Table:Cff::TopDict]
  # @param file [TTFunk::File]
  # @param offset [Integer]
  # @param length [Integer]
  # @return [FdSelector] a new instance of FdSelector
  #
  # source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#43
  def initialize(top_dict, file, offset, length = T.unsafe(nil)); end

  # Get font dict index for glyph ID.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#51
  def [](glyph_id); end

  # Iterate over font dicts for each glyph ID.
  #
  # @return [void]
  # @yieldparam font [Integer] dict index.
  #
  # source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#81
  def each; end

  # Encode Font dict selector.
  #
  # @param charmap [Hash{Integer => Hash}] keys are the charac codes,
  #   values are hashes:
  #   * `:old` (<tt>Integer</tt>) - glyph ID in the original font.
  #   * `:new` (<tt>Integer</tt>) - glyph ID in the subset font.
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#94
  def encode(charmap); end

  # Number of entries.
  #
  # @return [Array<Integer>] if format is array.
  # @return [Array<Array(Range, Integer)>] if format is range.
  #
  # source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#33
  def entries; end

  # Number of encoded items.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#28
  def items_count; end

  # Number of glyphs.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#37
  def n_glyphs; end

  # Top dict.
  #
  # @return [TTFunk::Table::Cff::TopDict]
  #
  # source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#24
  def top_dict; end

  private

  # source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#182
  def format_sym; end

  # source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#145
  def parse!; end

  # source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#125
  def range_cache; end

  # values is an array of [new_gid, fd_index] pairs
  #
  # source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#130
  def rangify_gids(values); end
end

# Array entry size.
#
# source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#20
TTFunk::Table::Cff::FdSelector::ARRAY_ENTRY_SIZE = T.let(T.unsafe(nil), Integer)

# Array format.
#
# source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#11
TTFunk::Table::Cff::FdSelector::ARRAY_FORMAT = T.let(T.unsafe(nil), Integer)

# Range entry size.
#
# source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#17
TTFunk::Table::Cff::FdSelector::RANGE_ENTRY_SIZE = T.let(T.unsafe(nil), Integer)

# Range format.
#
# source://ttfunk//lib/ttfunk/table/cff/fd_selector.rb#14
TTFunk::Table::Cff::FdSelector::RANGE_FORMAT = T.let(T.unsafe(nil), Integer)

# CFF Font dict.
#
# source://ttfunk//lib/ttfunk/table/cff/font_dict.rb#7
class TTFunk::Table::Cff::FontDict < ::TTFunk::Table::Cff::Dict
  # @param top_dict [TTFunk::Table:Cff::TopDict]
  # @param file [TTFunk::File]
  # @param offset [Integer]
  # @param length [Integer]
  # @return [FontDict] a new instance of FontDict
  #
  # source://ttfunk//lib/ttfunk/table/cff/font_dict.rb#25
  def initialize(top_dict, file, offset, length = T.unsafe(nil)); end

  # Encode dict.
  #
  # @return [TTFunk::EncodedString]
  #
  # source://ttfunk//lib/ttfunk/table/cff/font_dict.rb#33
  def encode; end

  # Finalize dict.
  #
  # @param new_cff_data [TTFunk::EncodedString]
  # @return [void]
  #
  # source://ttfunk//lib/ttfunk/table/cff/font_dict.rb#52
  def finalize(new_cff_data); end

  # Private dict.
  #
  # @return [TTFunk::Table::Cff::PrivateDict, nil]
  #
  # source://ttfunk//lib/ttfunk/table/cff/font_dict.rb#67
  def private_dict; end

  # Top dict.
  #
  # @return [TTFunk::Table::Cff::TopDict]
  #
  # source://ttfunk//lib/ttfunk/table/cff/font_dict.rb#19
  def top_dict; end

  private

  # source://ttfunk//lib/ttfunk/table/cff/font_dict.rb#82
  def encode_private; end
end

# Operators we care about in this dict.
#
# source://ttfunk//lib/ttfunk/table/cff/font_dict.rb#12
TTFunk::Table::Cff::FontDict::OPERATORS = T.let(T.unsafe(nil), Hash)

# Inverse operator mapping.
#
# source://ttfunk//lib/ttfunk/table/cff/font_dict.rb#15
TTFunk::Table::Cff::FontDict::OPERATOR_CODES = T.let(T.unsafe(nil), Hash)

# Length of placeholders.
#
# source://ttfunk//lib/ttfunk/table/cff/font_dict.rb#9
TTFunk::Table::Cff::FontDict::PLACEHOLDER_LENGTH = T.let(T.unsafe(nil), Integer)

# CFF Font Dict Index.
#
# source://ttfunk//lib/ttfunk/table/cff/font_index.rb#7
class TTFunk::Table::Cff::FontIndex < ::TTFunk::Table::Cff::Index
  # @param top_dict [TTFunk::Table:Cff::TopDict]
  # @param file [TTFunk::File]
  # @param offset [Integer]
  # @param length [Integer]
  # @return [FontIndex] a new instance of FontIndex
  #
  # source://ttfunk//lib/ttfunk/table/cff/font_index.rb#16
  def initialize(top_dict, file, offset, length = T.unsafe(nil)); end

  # Finalize index.
  #
  # @param new_cff_data [TTFunk::EncodedString]
  # @return [void]
  #
  # source://ttfunk//lib/ttfunk/table/cff/font_index.rb#25
  def finalize(new_cff_data); end

  # Top dict.
  #
  # @return [TTFunk::Table::Cff::TopDict]
  #
  # source://ttfunk//lib/ttfunk/table/cff/font_index.rb#10
  def top_dict; end

  private

  # source://ttfunk//lib/ttfunk/table/cff/font_index.rb#31
  def decode_item(_index, offset, length); end

  # source://ttfunk//lib/ttfunk/table/cff/font_index.rb#35
  def encode_items(*_arg0); end
end

# CFF Header.
#
# source://ttfunk//lib/ttfunk/table/cff/header.rb#7
class TTFunk::Table::Cff::Header < ::TTFunk::SubTable
  # Size of all offsets from beginning of table.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/header.rb#22
  def absolute_offset_size; end

  # Encode header.
  #
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/cff/header.rb#34
  def encode; end

  # Size of the header itself.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/header.rb#18
  def header_size; end

  # Length of header.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/header.rb#27
  def length; end

  # CFF table major version.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/header.rb#10
  def major; end

  # CFF table minor version.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/header.rb#14
  def minor; end

  private

  # source://ttfunk//lib/ttfunk/table/cff/header.rb#40
  def parse!; end
end

# CFF Index.
#
# source://ttfunk//lib/ttfunk/table/cff/index.rb#7
class TTFunk::Table::Cff::Index < ::TTFunk::SubTable
  include ::Enumerable

  # Get value by index.
  #
  # @param index [Integer]
  # @return [any]
  #
  # source://ttfunk//lib/ttfunk/table/cff/index.rb#14
  def [](index); end

  # Iterate over index items.
  #
  # @overload each
  # @overload each
  #
  # source://ttfunk//lib/ttfunk/table/cff/index.rb#32
  def each(&block); end

  # Encode index.
  #
  # @param args all arguments are passed to `encode_item` method.
  # @return [TTFunk::EncodedString]
  #
  # source://ttfunk//lib/ttfunk/table/cff/index.rb#51
  def encode(*args); end

  # Numer of items in this index.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/index.rb#43
  def items_count; end

  private

  # Returns the value of attribute data_reference_offset.
  #
  # source://ttfunk//lib/ttfunk/table/cff/index.rb#83
  def data_reference_offset; end

  # By default do nothing
  #
  # source://ttfunk//lib/ttfunk/table/cff/index.rb#102
  def decode_item(index, _offset, _length); end

  # Returns an array of EncodedString elements (plain strings,
  # placeholders, or EncodedString instances). Each element is supposed to
  # represent an encoded item.
  #
  # This is the place to do all the filtering, reordering, or individual
  # item encoding.
  #
  # It gets all the arguments `encode` gets.
  #
  # source://ttfunk//lib/ttfunk/table/cff/index.rb#97
  def encode_items(*_arg0); end

  # source://ttfunk//lib/ttfunk/table/cff/index.rb#106
  def encode_offset(offset, offset_size); end

  # source://ttfunk//lib/ttfunk/table/cff/index.rb#85
  def entry_cache; end

  # Returns the value of attribute items.
  #
  # source://ttfunk//lib/ttfunk/table/cff/index.rb#81
  def items; end

  # Returns the value of attribute offsets.
  #
  # source://ttfunk//lib/ttfunk/table/cff/index.rb#82
  def offsets; end

  # source://ttfunk//lib/ttfunk/table/cff/index.rb#119
  def parse!; end

  # source://ttfunk//lib/ttfunk/table/cff/index.rb#151
  def unpack_offset(offset_data, offset_size); end
end

# CFF Index with indexing starting at 1.
#
# source://ttfunk//lib/ttfunk/table/cff/one_based_index.rb#9
class TTFunk::Table::Cff::OneBasedIndex
  extend ::Forwardable

  # @param args [Array] all params are passed to the base index.
  # @return [OneBasedIndex] a new instance of OneBasedIndex
  # @see Index
  #
  # source://ttfunk//lib/ttfunk/table/cff/one_based_index.rb#25
  def initialize(*args); end

  # Get item by index.
  #
  # @param idx [Integer]
  # @raise [IndexError] when requested index is 0.
  # @return [any]
  #
  # source://ttfunk//lib/ttfunk/table/cff/one_based_index.rb#34
  def [](idx); end

  # Underlaying Index.
  #
  # @return [TTFunk::Table::Cff::Index]
  #
  # source://ttfunk//lib/ttfunk/table/cff/one_based_index.rb#21
  def base_index; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def encode(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def items_count(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def length(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def table_offset(*args, **_arg1, &block); end
end

# Path. Mostly used for CFF glyph outlines.
#
# source://ttfunk//lib/ttfunk/table/cff/path.rb#7
class TTFunk::Table::Cff::Path
  # @return [Path] a new instance of Path
  #
  # source://ttfunk//lib/ttfunk/table/cff/path.rb#19
  def initialize; end

  # Close current contour.
  #
  # @return [void]
  #
  # source://ttfunk//lib/ttfunk/table/cff/path.rb#60
  def close_path; end

  # Commands in this path.
  #
  # @return [Array]
  #
  # source://ttfunk//lib/ttfunk/table/cff/path.rb#13
  def commands; end

  # Add a Bezier curve. Current position is the first control point, (`x1`,
  # `y1`) is the second, (`x2`, `y2`) is the third, and (`x`, `y`) is the
  # last control point.
  #
  # @param x1 [Integer, Float]
  # @param y1 [Integer, Float]
  # @param x2 [Integer, Float]
  # @param y2 [Integer, Float]
  # @param x [Integer, Float]
  # @param y [Integer, Float]
  # @return [void]
  #
  # source://ttfunk//lib/ttfunk/table/cff/path.rb#53
  def curve_to(x1, y1, x2, y2, x, y); end

  # Add a line to coordinates.
  #
  # @param x [Integer, Float]
  # @param y [Integer, Float]
  # @return [void]
  #
  # source://ttfunk//lib/ttfunk/table/cff/path.rb#38
  def line_to(x, y); end

  # Move implicit cursor to coordinates.
  #
  # @param x [Integer, Float]
  # @param y [Integer, Float]
  # @return [void]
  #
  # source://ttfunk//lib/ttfunk/table/cff/path.rb#29
  def move_to(x, y); end

  # Number of contours in this path.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/path.rb#17
  def number_of_contours; end

  # Reposition and scale path.
  #
  # @param x [Integer, Float] new horizontal position.
  # @param y [Integer, Float] new vertical position.
  # @param font_size [Integer, Float] font size.
  # @param units_per_em [Integer] units per Em as defined in the font.
  # @return [TTFunk::Table::Cff::Path]
  #
  # source://ttfunk//lib/ttfunk/table/cff/path.rb#72
  def render(x: T.unsafe(nil), y: T.unsafe(nil), font_size: T.unsafe(nil), units_per_em: T.unsafe(nil)); end

  private

  # source://ttfunk//lib/ttfunk/table/cff/path.rb#101
  def format_values(command); end
end

# Close path command.
#
# source://ttfunk//lib/ttfunk/table/cff/path.rb#9
TTFunk::Table::Cff::Path::CLOSE_PATH_CMD = T.let(T.unsafe(nil), Array)

# CFF Private dict.
#
# source://ttfunk//lib/ttfunk/table/cff/private_dict.rb#7
class TTFunk::Table::Cff::PrivateDict < ::TTFunk::Table::Cff::Dict
  # Default Width X.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/private_dict.rb#75
  def default_width_x; end

  # Encode dict.
  #
  # @return [TTFunk::EncodedString]
  #
  # source://ttfunk//lib/ttfunk/table/cff/private_dict.rb#30
  def encode; end

  # Finalize dict.
  #
  # @param private_dict_data [TTFunk::EncodedString]
  # @return [void]
  #
  # source://ttfunk//lib/ttfunk/table/cff/private_dict.rb#51
  def finalize(private_dict_data); end

  # Nominal Width X.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/private_dict.rb#86
  def nominal_width_x; end

  # Subroutine index.
  #
  # @return [TTFunk::Table::Cff::SubrIndex, nil]
  #
  # source://ttfunk//lib/ttfunk/table/cff/private_dict.rb#65
  def subr_index; end

  private

  # source://ttfunk//lib/ttfunk/table/cff/private_dict.rb#96
  def encode_subrs; end
end

# Default value of Default Width X.
#
# source://ttfunk//lib/ttfunk/table/cff/private_dict.rb#9
TTFunk::Table::Cff::PrivateDict::DEFAULT_WIDTH_X_DEFAULT = T.let(T.unsafe(nil), Integer)

# Default value of Nominal Width X.
#
# source://ttfunk//lib/ttfunk/table/cff/private_dict.rb#12
TTFunk::Table::Cff::PrivateDict::DEFAULT_WIDTH_X_NOMINAL = T.let(T.unsafe(nil), Integer)

# Operators we care about in this dict.
#
# source://ttfunk//lib/ttfunk/table/cff/private_dict.rb#18
TTFunk::Table::Cff::PrivateDict::OPERATORS = T.let(T.unsafe(nil), Hash)

# Inverse operator mapping.
#
# source://ttfunk//lib/ttfunk/table/cff/private_dict.rb#25
TTFunk::Table::Cff::PrivateDict::OPERATOR_CODES = T.let(T.unsafe(nil), Hash)

# Length of placeholders.
#
# source://ttfunk//lib/ttfunk/table/cff/private_dict.rb#15
TTFunk::Table::Cff::PrivateDict::PLACEHOLDER_LENGTH = T.let(T.unsafe(nil), Integer)

# CFF Subroutine index.
#
# source://ttfunk//lib/ttfunk/table/cff/subr_index.rb#7
class TTFunk::Table::Cff::SubrIndex < ::TTFunk::Table::Cff::Index
  # Subroutine index biase. For correct subroutine selection the
  # calculated bias must be added to the subroutine number operand before
  # accessing the index.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/subr_index.rb#12
  def bias; end
end

# Table tag. The extra space is important.
#
# source://ttfunk//lib/ttfunk/table/cff.rb#27
TTFunk::Table::Cff::TAG = T.let(T.unsafe(nil), String)

# CFF top dict.
#
# source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#7
class TTFunk::Table::Cff::TopDict < ::TTFunk::Table::Cff::Dict
  # CFF table in this file.
  #
  # @return [TTFunk::Table::Cff]
  #
  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#207
  def cff; end

  # Ofsset of CFF table in the file.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#214
  def cff_offset; end

  # Charset specified in this dict.
  #
  # @return [TTFunk::Table::Cff::Charset, nil]
  #
  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#123
  def charset; end

  # Charstring type specified in this dict.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#167
  def charstring_type; end

  # Charstrings index specified in this dict.
  #
  # > OpenType fonts with TrueType outlines use a glyph index to specify
  #   and access glyphs within a font; e.g., to index within the `loca`
  #   table and thereby access glyph data in the `glyf` table. This
  #   concept is retained in OpenType CFF fonts, except that glyph data is
  #   accessed through the CharStrings INDEX of the CFF table.
  #
  # > --- [CFF  Compact Font Format Table](https://www.microsoft.com/typography/otspec/cff.htm)
  #
  # @return [TTFunk::Table::Cff::CharstringsIndex, nil]
  #
  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#157
  def charstrings_index; end

  # Encode dict.
  #
  # @return [TTFunk::EncodedString]
  #
  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#41
  def encode(*_arg0); end

  # Encoding specified in this dict.
  #
  # @return [TTFunk::Table::Cff::Encoding, nil]
  #
  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#137
  def encoding; end

  # Finalize the table.
  #
  # @param new_cff_data [TTFunk::EncodedString]
  # @param charmap [Hash{Integer => Hash}] keys are the charac codes,
  #   values are hashes:
  #   * `:old` (<tt>Integer</tt>) - glyph ID in the original font.
  #   * `:new` (<tt>Integer</tt>) - glyph ID in the subset font.
  # @return [void]
  #
  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#68
  def finalize(new_cff_data, charmap); end

  # Font dict selector specified in this dict.
  #
  # @return [TTFunk::Table::Cff::FdSelector, nil]
  #
  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#185
  def font_dict_selector; end

  # Font index specified in this dict.
  #
  # @return [TTFunk::Table::Cff::FontIndex, nil]
  #
  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#175
  def font_index; end

  # Is Registry Ordering Supplement present in this dict?
  #
  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#114
  def is_cid_font?; end

  # Private dict specified in this dict.
  #
  # @return [TTFunk::Table::Cff::PrivateDict, nil]
  #
  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#195
  def private_dict; end

  # Registry Ordering Supplement.
  #
  # @return [Array(Integer, Integer, Integer), nil]
  #
  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#107
  def ros; end

  # Is Registry Ordering Supplement present in this dict?
  #
  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#114
  def ros?; end

  private

  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#244
  def encode_charstring_type(charstring_type); end

  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#220
  def encode_private; end

  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#234
  def finalize_subtable(new_cff_data, name, table_data); end

  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#240
  def pointer_operator?(operator); end
end

# Default charstring type.
#
# source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#9
TTFunk::Table::Cff::TopDict::DEFAULT_CHARSTRING_TYPE = T.let(T.unsafe(nil), Integer)

# All the operators we currently care about.
#
# source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#29
TTFunk::Table::Cff::TopDict::OPERATORS = T.let(T.unsafe(nil), Hash)

# Inverse operator mapping.
#
# source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#36
TTFunk::Table::Cff::TopDict::OPERATOR_CODES = T.let(T.unsafe(nil), Hash)

# Length of placeholders for other operators.
#
# source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#15
TTFunk::Table::Cff::TopDict::PLACEHOLDER_LENGTH = T.let(T.unsafe(nil), Integer)

# Operators whose values are offsets that point to other parts
# of the file.
#
# source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#19
TTFunk::Table::Cff::TopDict::POINTER_OPERATORS = T.let(T.unsafe(nil), Hash)

# Length of placeholders for pointer operators.
#
# source://ttfunk//lib/ttfunk/table/cff/top_dict.rb#12
TTFunk::Table::Cff::TopDict::POINTER_PLACEHOLDER_LENGTH = T.let(T.unsafe(nil), Integer)

# CFF Index conatining Top dict.
#
# source://ttfunk//lib/ttfunk/table/cff/top_index.rb#7
class TTFunk::Table::Cff::TopIndex < ::TTFunk::Table::Cff::Index
  private

  # source://ttfunk//lib/ttfunk/table/cff/top_index.rb#10
  def decode_item(_index, offset, length); end

  # source://ttfunk//lib/ttfunk/table/cff/top_index.rb#14
  def encode_items(*_arg0); end
end

# Character to Glyph Index Mapping (`cmap`) table.
#
# source://ttfunk//lib/ttfunk/table/cmap.rb#6
class TTFunk::Table::Cmap < ::TTFunk::Table
  # Encoding tables.
  #
  # @return [Array<TTFunk::Table::Cmap::Subtable>]
  #
  # source://ttfunk//lib/ttfunk/table/cmap.rb#13
  def tables; end

  # Get Unicode encoding records.
  #
  # @return [Array<TTFunk::Table::Cmap::Subtable>]
  #
  # source://ttfunk//lib/ttfunk/table/cmap.rb#38
  def unicode; end

  # Table version.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cmap.rb#9
  def version; end

  private

  # source://ttfunk//lib/ttfunk/table/cmap.rb#49
  def parse!; end

  class << self
    # Encode table.
    #
    # @param charmap [Hash{Integer => Integer}]
    # @param encoding [Symbol]
    # @return [Hash] * `:charmap` (<tt>Hash{Integer => Hash}</tt>) keys are the characrers in
    #   `charset`, values are hashes:
    #   * `:old` (<tt>Integer</tt>) - glyph ID in the original font.
    #   * `:new` (<tt>Integer</tt>) - glyph ID in the subset font.
    #   that maps the characters in charmap to a
    #   * `:table` (<tt>String</tt>) - serialized table.
    #   * `:max_glyph_id` (<tt>Integer</tt>) - maximum glyph ID in the new font.
    #
    # source://ttfunk//lib/ttfunk/table/cmap.rb#27
    def encode(charmap, encoding); end
  end
end

# Format 0: Byte encoding table.
#
# This module conditionally extends {TTFunk::Table::Cmap::Subtable}.
#
# source://ttfunk//lib/ttfunk/table/cmap/format00.rb#9
module TTFunk::Table::Cmap::Format00
  # Get glyph ID for character code.
  #
  # @param code [Integer] character code.
  # @return [Integer] glyph ID.
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format00.rb#53
  def [](code); end

  # Code map.
  #
  # @return [Array<Integer>]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format00.rb#16
  def code_map; end

  # Language.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format00.rb#12
  def language; end

  # Is this encoding record format supported?
  #
  # @return [true]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format00.rb#60
  def supported?; end

  private

  # source://ttfunk//lib/ttfunk/table/cmap/format00.rb#66
  def parse_cmap!; end

  class << self
    # Encode the encoding record to format 0.
    #
    # @param charmap [Hash{Integer => Integer}] a hash mapping character
    #   codes to glyph ids (where the glyph ids are from the original font).
    # @return [Hash] * `:charmap` (<tt>Hash{Integer => Hash}</tt>) keys are the characrers in
    #   `charset`, values are hashes:
    #   * `:old` (<tt>Integer</tt>) - glyph ID in the original font.
    #   * `:new` (<tt>Integer</tt>) - glyph ID in the subset font.
    #   that maps the characters in charmap to a
    #   * `:subtable` (<tt>String</tt>) - serialized encoding record.
    #   * `:max_glyph_id` (<tt>Integer</tt>) - maximum glyph ID in the new font.
    #
    # source://ttfunk//lib/ttfunk/table/cmap/format00.rb#30
    def encode(charmap); end
  end
end

# Format 4: Segment mapping to delta values.
#
# This module conditionally extends {TTFunk::Table::Cmap::Subtable}.
#
# source://ttfunk//lib/ttfunk/table/cmap/format04.rb#9
module TTFunk::Table::Cmap::Format04
  # Get glyph ID for character code.
  #
  # @param code [Integer] character code.
  # @return [Integer] glyph ID.
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format04.rb#113
  def [](code); end

  # Code map.
  #
  # @return [Hash{Integer => Integer}]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format04.rb#16
  def code_map; end

  # Language.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format04.rb#12
  def language; end

  # Is this encoding record format supported?
  #
  # @return [true]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format04.rb#120
  def supported?; end

  private

  # source://ttfunk//lib/ttfunk/table/cmap/format04.rb#126
  def parse_cmap!; end

  class << self
    # Encode the encoding record to format 4.
    #
    # @param charmap [Hash{Integer => Integer}] a hash mapping character
    #   codes to glyph IDs from the original font.
    # @return [Hash] * `:charmap` (<tt>Hash{Integer => Hash}</tt>) keys are the characrers in
    #   `charset`, values are hashes:
    #   * `:old` (<tt>Integer</tt>) - glyph ID in the original font.
    #   * `:new` (<tt>Integer</tt>) - glyph ID in the subset font.
    #   that maps the characters in charmap to a
    #   * `:subtable` (<tt>String</tt>) - serialized encoding record.
    #   * `:max_glyph_id` (<tt>Integer</tt>) - maximum glyph ID in the new font.
    #
    # source://ttfunk//lib/ttfunk/table/cmap/format04.rb#30
    def encode(charmap); end
  end
end

# Format 6: Trimmed table mapping.
#
# This module conditionally extends {TTFunk::Table::Cmap::Subtable}.
#
# source://ttfunk//lib/ttfunk/table/cmap/format06.rb#9
module TTFunk::Table::Cmap::Format06
  # Get glyph ID for character code.
  #
  # @param code [Integer] character code.
  # @return [Integer] glyph ID.
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format06.rb#58
  def [](code); end

  # Code map.
  #
  # @return [Hash{Integer => Integer}]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format06.rb#16
  def code_map; end

  # Language.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format06.rb#12
  def language; end

  # Is this encoding record format supported?
  #
  # @return [true]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format06.rb#65
  def supported?; end

  private

  # source://ttfunk//lib/ttfunk/table/cmap/format06.rb#71
  def parse_cmap!; end

  class << self
    # Encode the encoding record to format 6.
    #
    # @param charmap [Hash{Integer => Integer}] a hash mapping character
    #   codes to glyph IDs from the original font.
    # @return [Hash] * `:charmap` (<tt>Hash{Integer => Hash}</tt>) keys are the characrers in
    #   `charset`, values are hashes:
    #   * `:old` (<tt>Integer</tt>) - glyph ID in the original font.
    #   * `:new` (<tt>Integer</tt>) - glyph ID in the subset font.
    #   that maps the characters in charmap to a
    #   * `:subtable` (<tt>String</tt>) - serialized encoding record.
    #   * `:max_glyph_id` (<tt>Integer</tt>) - maximum glyph ID in the new font.
    #
    # source://ttfunk//lib/ttfunk/table/cmap/format06.rb#30
    def encode(charmap); end
  end
end

# Format 10: Trimmed array.
#
# This module conditionally extends {TTFunk::Table::Cmap::Subtable}.
#
# source://ttfunk//lib/ttfunk/table/cmap/format10.rb#9
module TTFunk::Table::Cmap::Format10
  # Get glyph ID for character code.
  #
  # @param code [Integer] character code.
  # @return [Integer] glyph ID.
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format10.rb#59
  def [](code); end

  # Code map.
  #
  # @return [Hash{Integer => Integer}]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format10.rb#16
  def code_map; end

  # Language.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format10.rb#12
  def language; end

  # Is this encoding record format supported?
  #
  # @return [true]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format10.rb#66
  def supported?; end

  private

  # source://ttfunk//lib/ttfunk/table/cmap/format10.rb#72
  def parse_cmap!; end

  class << self
    # Encode the encoding record to format 10.
    #
    # @param charmap [Hash{Integer => Integer}] a hash mapping character
    #   codes to glyph IDs from the original font.
    # @return [Hash] * `:charmap` (<tt>Hash{Integer => Hash}</tt>) keys are the characrers in
    #   `charset`, values are hashes:
    #   * `:old` (<tt>Integer</tt>) - glyph ID in the original font.
    #   * `:new` (<tt>Integer</tt>) - glyph ID in the subset font.
    #   that maps the characters in charmap to a
    #   * `:subtable` (<tt>String</tt>) - serialized encoding record.
    #   * `:max_glyph_id` (<tt>Integer</tt>) - maximum glyph ID in the new font.
    #
    # source://ttfunk//lib/ttfunk/table/cmap/format10.rb#30
    def encode(charmap); end
  end
end

# Format 12: Segmented coverage.
#
# This module conditionally extends {TTFunk::Table::Cmap::Subtable}.
#
# source://ttfunk//lib/ttfunk/table/cmap/format12.rb#9
module TTFunk::Table::Cmap::Format12
  # Get glyph ID for character code.
  #
  # @param code [Integer] character code.
  # @return [Integer] glyph ID.
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format12.rb#72
  def [](code); end

  # Code map.
  #
  # @return [Hash{Integer => Integer}]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format12.rb#16
  def code_map; end

  # Language.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format12.rb#12
  def language; end

  # Is this encoding record format supported?
  #
  # @return [true]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/format12.rb#79
  def supported?; end

  private

  # source://ttfunk//lib/ttfunk/table/cmap/format12.rb#85
  def parse_cmap!; end

  class << self
    # Encode the encoding record to format 12.
    #
    # @param charmap [Hash{Integer => Integer}] a hash mapping character
    #   codes to glyph IDs from the original font.
    # @return [Hash] * `:charmap` (<tt>Hash{Integer => Hash}</tt>) keys are the characrers in
    #   `charset`, values are hashes:
    #   * `:old` (<tt>Integer</tt>) - glyph ID in the original font.
    #   * `:new` (<tt>Integer</tt>) - glyph ID in the subset font.
    #   that maps the characters in charmap to a
    #   * `:subtable` (<tt>String</tt>) - serialized encoding record.
    #   * `:max_glyph_id` (<tt>Integer</tt>) - maximum glyph ID in the new font.
    #
    # source://ttfunk//lib/ttfunk/table/cmap/format12.rb#30
    def encode(charmap); end
  end
end

# Character to Glyph Index encoding record.
# This class can be extended with a format-specific
#
# @see TTFunk::Table::Cmap::Format00
# @see TTFunk::Table::Cmap::Format04
# @see TTFunk::Table::Cmap::Format06
# @see TTFunk::Table::Cmap::Format10
# @see TTFunk::Table::Cmap::Format12
#
# source://ttfunk//lib/ttfunk/table/cmap/subtable.rb#16
class TTFunk::Table::Cmap::Subtable
  include ::TTFunk::Reader

  # @param file [TTFunk::File]
  # @param table_start [Integer]
  # @return [Subtable] a new instance of Subtable
  #
  # source://ttfunk//lib/ttfunk/table/cmap/subtable.rb#86
  def initialize(file, table_start); end

  # Get glyph ID for character code.
  #
  # @param _code [Integer] character code.
  # @raise [NotImplementedError]
  # @return [Integer] glyph ID.
  #
  # source://ttfunk//lib/ttfunk/table/cmap/subtable.rb#125
  def [](_code); end

  # Platform-specific encoding ID.
  #
  # @return [Integere]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/subtable.rb#25
  def encoding_id; end

  # Record encoding format.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/subtable.rb#29
  def format; end

  # Platform ID.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/subtable.rb#21
  def platform_id; end

  # Is this encoding record format supported?
  #
  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/subtable.rb#117
  def supported?; end

  # Is this an encoding record for Unicode?
  #
  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/table/cmap/subtable.rb#109
  def unicode?; end

  private

  # source://ttfunk//lib/ttfunk/table/cmap/subtable.rb#131
  def parse_cmap!; end

  class << self
    # Encode encoding record.
    #
    # @param charmap [Hash{Integer => Integer}] keys are code points in the
    #   used encoding, values are Unicode code points.
    # @param encoding [Symbol] - one of the encodign mapping in
    #   {ENCODING_MAPPINGS}
    # @return [Hash] * `:platform_id` (<tt>Integer</tt>) - Platform ID of this encoding record.
    #   * `:encoding_id` (<tt>Integer</tt>) - Encodign ID of this encoding record.
    #   * `:subtable` (<tt>String</tt>) - encoded encoding record.
    #   * `:max_glyph_id` (<tt>Integer</tt>) - maximum glyph ID in this encoding
    #   record.
    #   * `:charmap` (<tt>Hash{Integer => Hash}</tt>) - keys are codepoints in this
    #   encoding record, values are hashes:
    #   * `:new` - new glyph ID.
    #   * `:old` - glyph ID in the original font.
    #
    # source://ttfunk//lib/ttfunk/table/cmap/subtable.rb#56
    def encode(charmap, encoding); end
  end
end

# Most used encoding mappings.
#
# source://ttfunk//lib/ttfunk/table/cmap/subtable.rb#32
TTFunk::Table::Cmap::Subtable::ENCODING_MAPPINGS = T.let(T.unsafe(nil), Hash)

# Digital Signature (`DSIG`) table.
#
# source://ttfunk//lib/ttfunk/table/dsig.rb#6
class TTFunk::Table::Dsig < ::TTFunk::Table
  # Permission flags.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/dsig.rb#43
  def flags; end

  # Signature records.
  #
  # @return [Array<SignatureRecord>]
  #
  # source://ttfunk//lib/ttfunk/table/dsig.rb#47
  def signatures; end

  # Table tag.
  #
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/dsig.rb#70
  def tag; end

  # Version umber of this table.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/dsig.rb#39
  def version; end

  private

  # source://ttfunk//lib/ttfunk/table/dsig.rb#76
  def parse!; end

  class << self
    # Encode table.
    #
    # **Note**: all signatures will be lost. This encodes an empty table
    # regardless whether the supplied table contains any signtaures or not.
    #
    # @param dsig [TTFunk::Table::Dsig]
    # @return [String]
    #
    # source://ttfunk//lib/ttfunk/table/dsig.rb#59
    def encode(dsig); end
  end
end

# Signature record.
#
# source://ttfunk//lib/ttfunk/table/dsig.rb#8
class TTFunk::Table::Dsig::SignatureRecord
  # @param format [Integer]
  # @param length [Integer]
  # @param offset [Integer]
  # @param signature [String]
  # @return [SignatureRecord] a new instance of SignatureRecord
  #
  # source://ttfunk//lib/ttfunk/table/dsig.rb#29
  def initialize(format, length, offset, signature); end

  # Format of the signature.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/dsig.rb#11
  def format; end

  # Length of signature in bytes.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/dsig.rb#15
  def length; end

  # Offset to the signature block from the beginning of the table.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/dsig.rb#19
  def offset; end

  # Signature PKCS#7 packet.
  #
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/dsig.rb#23
  def signature; end
end

# Table tag.
#
# source://ttfunk//lib/ttfunk/table/dsig.rb#50
TTFunk::Table::Dsig::TAG = T.let(T.unsafe(nil), String)

# Glyph Data (`glyf`) table.
#
# source://ttfunk//lib/ttfunk/table/glyf.rb#8
class TTFunk::Table::Glyf < ::TTFunk::Table
  # Get glyph by ID.
  #
  # @param glyph_id [Integer]
  # @return [TTFunk::Table::Glyf::Simple, TTFunk::Table::Glyf::Compound, nil]
  #
  # source://ttfunk//lib/ttfunk/table/glyf.rb#39
  def for(glyph_id); end

  private

  # source://ttfunk//lib/ttfunk/table/glyf.rb#65
  def parse!; end

  class << self
    # Encode table.
    #
    # @param glyphs [Hash] a hash mapping (old) glyph-ids to glyph objects
    # @param new_to_old [Hash{Integer => Integer}] a hash mapping new glyph
    #   IDs to glyph IDs in the original font.
    # @param old_to_new [Hash{Integer => Integer}] a hash mapping old glyph
    #   IDs to new glyph IDs.
    # @return [Hash] * `:table` (<tt>String</tt>) - encoded table.
    #   * `:offsets` (<tt>Array\<Integer></tt>) - glyph offsets in the table.
    #
    # source://ttfunk//lib/ttfunk/table/glyf.rb#19
    def encode(glyphs, new_to_old, old_to_new); end
  end
end

# Composite TrueType glyph.
#
# source://ttfunk//lib/ttfunk/table/glyf/compound.rb#9
class TTFunk::Table::Glyf::Compound
  include ::TTFunk::Reader

  # @param id [Integer] glyph ID.
  # @param raw [String]
  # @return [Compound] a new instance of Compound
  #
  # source://ttfunk//lib/ttfunk/table/glyf/compound.rb#85
  def initialize(id, raw); end

  # Is this a composite glyph?
  #
  # @return [true]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/compound.rb#136
  def compound?; end

  # IDs of compound glyphs.
  #
  # source://ttfunk//lib/ttfunk/table/glyf/compound.rb#62
  def glyph_ids; end

  # Glyph ID.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/compound.rb#35
  def id; end

  # Number of contours in this glyph.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/compound.rb#43
  def number_of_contours; end

  # Binary serialization of this glyph.
  #
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/compound.rb#39
  def raw; end

  # Recode glyph.
  #
  # @param mapping [Hash{Integer => Integer}] a hash mapping old glyph IDs
  #   to new glyph IDs.
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/compound.rb#145
  def recode(mapping); end

  # Maximum x for coordinate.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/compound.rb#55
  def x_max; end

  # Minimum x for coordinate.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/compound.rb#47
  def x_min; end

  # Maximum y for coordinate.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/compound.rb#59
  def y_max; end

  # Minimum y for coordinate.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/compound.rb#51
  def y_min; end
end

# Flags bit 0: arg1 and arg2 are words.
#
# source://ttfunk//lib/ttfunk/table/glyf/compound.rb#13
TTFunk::Table::Glyf::Compound::ARG_1_AND_2_ARE_WORDS = T.let(T.unsafe(nil), Integer)

# Component glyph.
#
# source://ttfunk//lib/ttfunk/table/glyf/compound.rb#81
class TTFunk::Table::Glyf::Compound::Component < ::Struct
  # x-offset for component or point number.
  #
  # @return [Integer]
  def arg1; end

  # x-offset for component or point number.
  #
  # @return [Integer]
  def arg1=(_); end

  # y-offset for component or point number.
  #
  # @return [Integer]
  def arg2; end

  # y-offset for component or point number.
  #
  # @return [Integer]
  def arg2=(_); end

  # Component flag.
  #
  # @return [Integer]
  def flags; end

  # Component flag.
  #
  # @return [Integer]
  def flags=(_); end

  # Glyph index of component.
  #
  # @return [Integer]
  def glyph_index; end

  # Glyph index of component.
  #
  # @return [Integer]
  def glyph_index=(_); end

  # Transformation.
  #
  # @return []
  def transform; end

  # Transformation.
  #
  # @return []
  def transform=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Flags bit 5: at least one more glyph after this one.
#
# source://ttfunk//lib/ttfunk/table/glyf/compound.rb#19
TTFunk::Table::Glyf::Compound::MORE_COMPONENTS = T.let(T.unsafe(nil), Integer)

# Flags bit 6: the x direction will use a different scale from the
# y direction.
#
# source://ttfunk//lib/ttfunk/table/glyf/compound.rb#23
TTFunk::Table::Glyf::Compound::WE_HAVE_AN_X_AND_Y_SCALE = T.let(T.unsafe(nil), Integer)

# Flags bit 3: there is a simple scale for the component.
#
# source://ttfunk//lib/ttfunk/table/glyf/compound.rb#16
TTFunk::Table::Glyf::Compound::WE_HAVE_A_SCALE = T.let(T.unsafe(nil), Integer)

# Flags bit 7: there is a 2 by 2 transformation that will be used to
# scale the component.
#
# source://ttfunk//lib/ttfunk/table/glyf/compound.rb#27
TTFunk::Table::Glyf::Compound::WE_HAVE_A_TWO_BY_TWO = T.let(T.unsafe(nil), Integer)

# Flags bit 8: following the last component are instructions for the
# composite character.
#
# source://ttfunk//lib/ttfunk/table/glyf/compound.rb#31
TTFunk::Table::Glyf::Compound::WE_HAVE_INSTRUCTIONS = T.let(T.unsafe(nil), Integer)

# TrueType-compatible representation of a CFF glyph.
#
# source://ttfunk//lib/ttfunk/table/glyf/path_based.rb#7
class TTFunk::Table::Glyf::PathBased
  # @param path [TTFunk::Table::Cff::Path]
  # @param horizontal_metrics [TTFunk::Table::Hmtx::HorizontalMetric]
  # @return [PathBased] a new instance of PathBased
  #
  # source://ttfunk//lib/ttfunk/table/glyf/path_based.rb#42
  def initialize(path, horizontal_metrics); end

  # Is this glyph compound?
  #
  # @return [false]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/path_based.rb#78
  def compound?; end

  # Glyph horizontal metrics.
  #
  # @return [TTFunk::Table::Hmtx::HorizontalMetric]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/path_based.rb#14
  def horizontal_metrics; end

  # Left side bearing.
  #
  # @return [Integer, Float]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/path_based.rb#34
  def left_side_bearing; end

  # Number of contour.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/path_based.rb#71
  def number_of_contours; end

  # Glyph outline.
  #
  # @return [TTFunk::Table::Cff::Path]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/path_based.rb#10
  def path; end

  # Rigth side bearing.
  #
  # @return [Integer, Float]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/path_based.rb#38
  def right_side_bearing; end

  # Maximum X.
  #
  # @return [Integer, Float]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/path_based.rb#26
  def x_max; end

  # Minimum X.
  #
  # @return [Integer, Float]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/path_based.rb#18
  def x_min; end

  # Maximum Y.
  #
  # @return [Integer, Float]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/path_based.rb#30
  def y_max; end

  # Minimum Y.
  #
  # @return [Integer, Float]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/path_based.rb#22
  def y_min; end
end

# Simple TrueType glyph
#
# source://ttfunk//lib/ttfunk/table/glyf/simple.rb#9
class TTFunk::Table::Glyf::Simple
  # @param id [Integer] glyph ID.
  # @param raw [String]
  # @return [Simple] a new instance of Simple
  #
  # source://ttfunk//lib/ttfunk/table/glyf/simple.rb#52
  def initialize(id, raw); end

  # Is this glyph compound?
  #
  # @return [false]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/simple.rb#69
  def compound?; end

  # End point index of last contour.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/simple.rb#83
  def end_point_of_last_contour; end

  # Point indices for the last point of each contour.
  #
  # @return [Array<Integer>]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/simple.rb#40
  def end_points_of_contours; end

  # Glyph ID.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/simple.rb#12
  def id; end

  # Total number of bytes for instructions.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/simple.rb#44
  def instruction_length; end

  # Instruction byte code.
  #
  # @return [Array<Integer>]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/simple.rb#48
  def instructions; end

  # Number of contours in this glyph.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/simple.rb#20
  def number_of_contours; end

  # Binary serialization of this glyph.
  #
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/simple.rb#16
  def raw; end

  # Recode glyph.
  #
  # @param _mapping Unused, here for API compatibility.
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/simple.rb#77
  def recode(_mapping); end

  # Maximum x for coordinate.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/simple.rb#32
  def x_max; end

  # Minimum x for coordinate.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/simple.rb#24
  def x_min; end

  # Maximum y for coordinate.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/simple.rb#36
  def y_max; end

  # Minimum y for coordinate.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/glyf/simple.rb#28
  def y_min; end
end

# Font Header (`head`) Table.
#
# source://ttfunk//lib/ttfunk/table/head.rb#8
class TTFunk::Table::Head < ::TTFunk::Table
  # Checksum adjustment.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#19
  def checksum_adjustment; end

  # Font creation time.
  #
  # @return [Integer] Long Date Time timestamp.
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#35
  def created; end

  # Flags.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#27
  def flags; end

  # Font direction hint. Deprecated, set to 2.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#67
  def font_direction_hint; end

  # Font revision.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#15
  def font_revision; end

  # Glyph data format.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#75
  def glyph_data_format; end

  # Index to Location format.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#71
  def index_to_loc_format; end

  # Smallest readable size in pixels.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#63
  def lowest_rec_ppem; end

  # Mac font style.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#59
  def mac_style; end

  # Magic number.
  #
  # @return [Integer] must be `0x5F0F3CF5`
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#23
  def magic_number; end

  # Font modification time.
  #
  # @return [Integer] Long Date Time timestamp.
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#39
  def modified; end

  # Units per Em.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#31
  def units_per_em; end

  # Table version.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#11
  def version; end

  # Maximum x coordinate across all glyph bounding boxes.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#51
  def x_max; end

  # Minimum x coordinate across all glyph bounding boxes.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#43
  def x_min; end

  # Maximum y coordinate across all glyph bounding boxes.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#55
  def y_max; end

  # Minimum y coordinate across all glyph bounding boxes.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/head.rb#47
  def y_min; end

  private

  # source://ttfunk//lib/ttfunk/table/head.rb#149
  def parse!; end

  class << self
    # Encode table.
    #
    # @param head [TTFunk::Table::Head]
    # @param loca [Hash] result of encoding Index to Location (`loca`) table
    # @param mapping [Hash{Integer => Integer}] keys are new glyph IDs, values
    #   are old glyph IDs
    # @return [EncodedString]
    #
    # source://ttfunk//lib/ttfunk/table/head.rb#92
    def encode(head, loca, mapping); end

    # Convert Long Date Time timestamp to Time.
    #
    # @param ldt [Float, Integer]
    # @return [Time]
    #
    # source://ttfunk//lib/ttfunk/table/head.rb#111
    def from_long_date_time(ldt); end

    # Convert Time to Long Date Time timestamp
    #
    # @param time [Time]
    # @return [Integer]
    #
    # source://ttfunk//lib/ttfunk/table/head.rb#118
    def to_long_date_time(time); end

    private

    # source://ttfunk//lib/ttfunk/table/head.rb#124
    def min_max_values_for(head, mapping); end
  end
end

# Horizontal Header (`hhea`) table.
#
# source://ttfunk//lib/ttfunk/table/hhea.rb#8
class TTFunk::Table::Hhea < ::TTFunk::Table
  # Maximum advance width value in `hmtx` table.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/hhea.rb#27
  def advance_width_max; end

  # Typographic ascent.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/hhea.rb#15
  def ascent; end

  # Caret offset.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/hhea.rb#66
  def caret_offset; end

  # Caret slope rise.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/hhea.rb#44
  def caret_slope_rise; end

  # Caret slope run.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/hhea.rb#55
  def caret_slope_run; end

  # @deprecated Use {caret_slope_rise} instead.
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/hhea.rb#49
  def carot_slope_rise; end

  # @deprecated Use {caret_slope_run} instead.
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/hhea.rb#60
  def carot_slope_run; end

  # Typographic descent.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/hhea.rb#19
  def descent; end

  # Typographic line gap.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/hhea.rb#23
  def line_gap; end

  # Metric data format. `0` for current format.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/hhea.rb#70
  def metric_data_format; end

  # Minimum left sidebearing value in `hmtx` table for glyphs with contours
  # (empty glyphs should be ignored).
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/hhea.rb#32
  def min_left_side_bearing; end

  # Minimum right sidebearing value.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/hhea.rb#36
  def min_right_side_bearing; end

  # Number of hMetric entries in `hmtx` table.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/hhea.rb#74
  def number_of_metrics; end

  # Table version
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/hhea.rb#11
  def version; end

  # Maximum extent.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/hhea.rb#40
  def x_max_extent; end

  private

  # source://ttfunk//lib/ttfunk/table/hhea.rb#131
  def parse!; end

  class << self
    # Encode table.
    #
    # @param hhea [TTFunk::Table::Hhea] table to encode.
    # @param hmtx [TTFunk::Table::Hmtx]
    # @param original [TTFunk::File] original font file.
    # @param mapping [Hash{Integer => Integer}] keys are new glyph IDs, values
    #   are old glyph IDs
    # @return [String]
    #
    # source://ttfunk//lib/ttfunk/table/hhea.rb#85
    def encode(hhea, hmtx, original, mapping); end

    private

    # source://ttfunk//lib/ttfunk/table/hhea.rb#99
    def min_max_values_for(original, mapping); end
  end
end

# Horizontal Metrics (`hmtx`) table.
#
# source://ttfunk//lib/ttfunk/table/hmtx.rb#8
class TTFunk::Table::Hmtx < ::TTFunk::Table
  # Get horizontal metric for glyph.
  #
  # @param glyph_id [Integer]
  # @return [HorizontalMetric]
  #
  # source://ttfunk//lib/ttfunk/table/hmtx.rb#54
  def for(glyph_id); end

  # Left side bearings.
  #
  # @return [Array<Ingteger>]
  #
  # source://ttfunk//lib/ttfunk/table/hmtx.rb#15
  def left_side_bearings; end

  # Glyph horizontal metrics.
  #
  # @return [Array<HorizontalMetric>]
  #
  # source://ttfunk//lib/ttfunk/table/hmtx.rb#11
  def metrics; end

  # Glyph widths.
  #
  # @return [Array<Integer>]
  #
  # source://ttfunk//lib/ttfunk/table/hmtx.rb#19
  def widths; end

  private

  # source://ttfunk//lib/ttfunk/table/hmtx.rb#65
  def metrics_cache; end

  # source://ttfunk//lib/ttfunk/table/hmtx.rb#69
  def parse!; end

  class << self
    # Encode table.
    #
    # @param hmtx [TTFunk::Table::Hmtx]
    # @param mapping [Hash{Integer => Integer}] keys are new glyph IDs, values
    #   are old glyph IDs
    # @return [Hash{:number_of_metrics => Integer, :table => String}] * `:number_of_metrics` - number of mertrics is the table.
    #   * `:table` - encoded table.
    #
    # source://ttfunk//lib/ttfunk/table/hmtx.rb#29
    def encode(hmtx, mapping); end
  end
end

# Horyzontal glyph metric.
#
# source://ttfunk//lib/ttfunk/table/hmtx.rb#48
class TTFunk::Table::Hmtx::HorizontalMetric < ::Struct
  # @return [Integer] Advance width.
  def advance_width; end

  # @return [Integer] Advance width.
  def advance_width=(_); end

  # @return [Integer] Left side bearing.
  def left_side_bearing; end

  # @return [Integer] Left side bearing.
  def left_side_bearing=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Kerning (`kern`) table
#
# source://ttfunk//lib/ttfunk/table/kern.rb#8
class TTFunk::Table::Kern < ::TTFunk::Table
  # Subtables.
  #
  # @return [Array<TTFunk::Table::Kern::Format0>]
  #
  # source://ttfunk//lib/ttfunk/table/kern.rb#15
  def tables; end

  # Table version
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/kern.rb#11
  def version; end

  private

  # source://ttfunk//lib/ttfunk/table/kern.rb#93
  def add_table(format, attributes = T.unsafe(nil)); end

  # source://ttfunk//lib/ttfunk/table/kern.rb#34
  def parse!; end

  # source://ttfunk//lib/ttfunk/table/kern.rb#47
  def parse_version_0_tables(_num_tables); end

  # source://ttfunk//lib/ttfunk/table/kern.rb#75
  def parse_version_1_tables(num_tables); end

  class << self
    # Encode table.
    #
    # @param kerning [TTFunk::Table::Kern]
    # @param mapping [Hash{Integer => Integer}] keys are new glyph IDs, values
    #   are old glyph IDs
    # @return [String, nil]
    #
    # source://ttfunk//lib/ttfunk/table/kern.rb#23
    def encode(kerning, mapping); end
  end
end

# Format 0 kerning subtable.
#
# source://ttfunk//lib/ttfunk/table/kern/format0.rb#9
class TTFunk::Table::Kern::Format0
  include ::TTFunk::Reader

  # @param attributes [Hash{Symbol => any}]
  # @return [Format0] a new instance of Format0
  #
  # source://ttfunk//lib/ttfunk/table/kern/format0.rb#21
  def initialize(attributes = T.unsafe(nil)); end

  # Subtable attributes.
  #
  # @return [Hash{Symbol => any}]
  #
  # source://ttfunk//lib/ttfunk/table/kern/format0.rb#14
  def attributes; end

  # Is this cross-stream kerning?
  #
  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/table/kern/format0.rb#52
  def cross_stream?; end

  # Is this horizontal kerning?
  #
  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/table/kern/format0.rb#46
  def horizontal?; end

  # Kerning pairs.
  #
  # @return [Hash{Array(Integer, Integer) => Integer}]
  #
  # source://ttfunk//lib/ttfunk/table/kern/format0.rb#18
  def pairs; end

  # Recode this subtable using the specified mapping.
  #
  # @param mapping [Hash{Integer => Integer}] keys are new glyph IDs,
  #   values are old glyph IDs
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/kern/format0.rb#61
  def recode(mapping); end

  # Is this vertical kerning?
  #
  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/table/kern/format0.rb#40
  def vertical?; end
end

# Index to Location table.
#
# source://ttfunk//lib/ttfunk/table/loca.rb#8
class TTFunk::Table::Loca < ::TTFunk::Table
  # Glyph offset by ID.
  #
  # @param glyph_id [Integer]
  # @return [Integer] - offset of the glyph in the `glyf` table
  #
  # source://ttfunk//lib/ttfunk/table/loca.rb#40
  def index_of(glyph_id); end

  # Glyph ofsets
  #
  # @return [Array<Integer>]
  #
  # source://ttfunk//lib/ttfunk/table/loca.rb#11
  def offsets; end

  # Size of encoded glyph.
  #
  # @param glyph_id [Integer]
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/loca.rb#48
  def size_of(glyph_id); end

  private

  # source://ttfunk//lib/ttfunk/table/loca.rb#54
  def parse!; end

  class << self
    # Encode table.
    #
    # @param offsets [Array<Integer>] an array of offsets, with each index
    #   corresponding to the glyph id with that index.
    # @return [Hash] result hash:
    #   * `:type` - the type of offset (to be encoded in the 'head' table):
    #   * `0` - short offsets
    #   * `1` - long offsets
    #   * `:table` - encoded bytes
    #
    # source://ttfunk//lib/ttfunk/table/loca.rb#22
    def encode(offsets); end
  end
end

# Maximum Profile (`maxp`) table
#
# source://ttfunk//lib/ttfunk/table/maxp.rb#8
class TTFunk::Table::Maxp < ::TTFunk::Table
  # Maximum contours in a composite glyph.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/maxp.rb#37
  def max_component_contours; end

  # Maximum levels of recursion.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/maxp.rb#77
  def max_component_depth; end

  # Maximum number of components referenced at "top level" for any composite
  # glyph.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/maxp.rb#73
  def max_component_elements; end

  # Maximum points in a composite glyph.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/maxp.rb#33
  def max_component_points; end

  # Maximum contours in a non-composite glyph.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/maxp.rb#29
  def max_contours; end

  # Number of FDEFs.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/maxp.rb#55
  def max_function_defs; end

  # Number of IDEFs.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/maxp.rb#59
  def max_instruction_defs; end

  # Maximum points in a non-composite glyph.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/maxp.rb#25
  def max_points; end

  # Maximum byte count for glyph instructions.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/maxp.rb#68
  def max_size_of_instructions; end

  # Maximum stack depth across Font Program, CVT Program and all glyph
  # instructions.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/maxp.rb#64
  def max_stack_elements; end

  # Number of Storage Area locations.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/maxp.rb#51
  def max_storage; end

  # Maximum points used in Z0.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/maxp.rb#47
  def max_twilight_points; end

  # Maximum zones.
  # * 1 if instructions do not use the twilight zone (Z0)
  # * 2 if instructions do use Z0
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/maxp.rb#43
  def max_zones; end

  # The number of glyphs in the font.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/maxp.rb#21
  def num_glyphs; end

  # Table version.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/maxp.rb#17
  def version; end

  private

  # source://ttfunk//lib/ttfunk/table/maxp.rb#205
  def parse!; end

  class << self
    # Encode table.
    #
    # @param maxp [TTFunk::Table::Maxp]
    # @param new2old_glyph [Hash{Integer => Integer}] keys are new glyph IDs, values
    #   are old glyph IDs.
    # @return [String]
    #
    # source://ttfunk//lib/ttfunk/table/maxp.rb#86
    def encode(maxp, new2old_glyph); end

    private

    # source://ttfunk//lib/ttfunk/table/maxp.rb#117
    def glyphs_from_ids(maxp, glyph_ids); end

    # source://ttfunk//lib/ttfunk/table/maxp.rb#125
    def stats_for(maxp, glyphs); end

    # source://ttfunk//lib/ttfunk/table/maxp.rb#155
    def stats_for_compound(maxp, glyphs); end

    # source://ttfunk//lib/ttfunk/table/maxp.rb#131
    def stats_for_simple(_maxp, glyphs); end

    # source://ttfunk//lib/ttfunk/table/maxp.rb#176
    def totals_for_compound(maxp, glyphs, depth); end
  end
end

# Default maximum levels of recursion.
#
# source://ttfunk//lib/ttfunk/table/maxp.rb#10
TTFunk::Table::Maxp::DEFAULT_MAX_COMPONENT_DEPTH = T.let(T.unsafe(nil), Integer)

# Size of full table version 1.
#
# source://ttfunk//lib/ttfunk/table/maxp.rb#13
TTFunk::Table::Maxp::MAX_V1_TABLE_LENGTH = T.let(T.unsafe(nil), Integer)

# Naming (`name`) table
#
# source://ttfunk//lib/ttfunk/table/name.rb#9
class TTFunk::Table::Name < ::TTFunk::Table
  # Compatible Full Names.
  #
  # @return [Array<NameString>]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#118
  def compatible_full; end

  # source://ttfunk//lib/ttfunk/table/name.rb#54
  def copyright; end

  # Descriptions.
  #
  # @return [Array<NameString>]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#90
  def description; end

  # Designers.
  #
  # @return [Array<NameString>]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#86
  def designer; end

  # Designer URLs.
  #
  # @return [Array<NameString>]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#98
  def designer_url; end

  # Name records.
  #
  # @return [Array<Hash>]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#46
  def entries; end

  # Font Family names.
  #
  # @return [Array<NameString>]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#58
  def font_family; end

  # Full font names.
  #
  # @return [Array<NameString>]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#70
  def font_name; end

  # Font Subfamily names.
  #
  # @return [Array<NameString>]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#62
  def font_subfamily; end

  # source://ttfunk//lib/ttfunk/table/name.rb#102
  def license; end

  # source://ttfunk//lib/ttfunk/table/name.rb#106
  def license_url; end

  # Manufacturer Names.
  #
  # @return [Array<NameString>]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#82
  def manufacturer; end

  # PostScript name for the font.
  #
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#222
  def postscript_name; end

  # Typographic Family names.
  #
  # @return [Array<NameString>]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#110
  def preferred_family; end

  # Typographic Subfamily names.
  #
  # @return [Array<NameString>]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#114
  def preferred_subfamily; end

  # Sample texts.
  #
  # @return [Array<NameString>]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#122
  def sample_text; end

  # Name strings.
  #
  # @return [Hash{Integer => NameString}]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#50
  def strings; end

  # Trademarks.
  #
  # @return [Array<NameString>]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#78
  def trademark; end

  # Unique font identifiers.
  #
  # @return [Array<NameString>]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#66
  def unique_subfamily; end

  # Vendor URLs.
  #
  # @return [Array<NameString>]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#94
  def vendor_url; end

  # Version strings.
  #
  # @return [Array<NameString>]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#74
  def version; end

  private

  # source://ttfunk//lib/ttfunk/table/name.rb#230
  def parse!; end

  class << self
    # Encode table.
    #
    # @param names [TTFunk::Table::Name]
    # @param key [String]
    # @return [String]
    #
    # source://ttfunk//lib/ttfunk/table/name.rb#187
    def encode(names, key = T.unsafe(nil)); end
  end
end

# Compatible Full ID.
#
# source://ttfunk//lib/ttfunk/table/name.rb#177
TTFunk::Table::Name::COMPATIBLE_FULL_NAME_ID = T.let(T.unsafe(nil), Integer)

# source://ttfunk//lib/ttfunk/table/name.rb#125
TTFunk::Table::Name::COPYRIGHT_NAME_ID = T.let(T.unsafe(nil), Integer)

# Description ID.
#
# source://ttfunk//lib/ttfunk/table/name.rb#156
TTFunk::Table::Name::DESCRIPTION_NAME_ID = T.let(T.unsafe(nil), Integer)

# Designer ID.
#
# source://ttfunk//lib/ttfunk/table/name.rb#153
TTFunk::Table::Name::DESIGNER_NAME_ID = T.let(T.unsafe(nil), Integer)

# Designer URL ID.
#
# source://ttfunk//lib/ttfunk/table/name.rb#162
TTFunk::Table::Name::DESIGNER_URL_NAME_ID = T.let(T.unsafe(nil), Integer)

# Font Family name ID.
#
# source://ttfunk//lib/ttfunk/table/name.rb#128
TTFunk::Table::Name::FONT_FAMILY_NAME_ID = T.let(T.unsafe(nil), Integer)

# Full font name that reflects all family and relevant subfamily
# descriptors ID.
#
# source://ttfunk//lib/ttfunk/table/name.rb#138
TTFunk::Table::Name::FONT_NAME_NAME_ID = T.let(T.unsafe(nil), Integer)

# Font Subfamily name ID.
#
# source://ttfunk//lib/ttfunk/table/name.rb#131
TTFunk::Table::Name::FONT_SUBFAMILY_NAME_ID = T.let(T.unsafe(nil), Integer)

# source://ttfunk//lib/ttfunk/table/name.rb#165
TTFunk::Table::Name::LICENSE_NAME_ID = T.let(T.unsafe(nil), Integer)

# source://ttfunk//lib/ttfunk/table/name.rb#168
TTFunk::Table::Name::LICENSE_URL_NAME_ID = T.let(T.unsafe(nil), Integer)

# Manufacturer Name ID.
#
# source://ttfunk//lib/ttfunk/table/name.rb#150
TTFunk::Table::Name::MANUFACTURER_NAME_ID = T.let(T.unsafe(nil), Integer)

# Name Record.
#
# source://ttfunk//lib/ttfunk/table/name.rb#11
class TTFunk::Table::Name::NameString < ::String
  # @param text [String]
  # @param platform_id [Integer]
  # @param encoding_id [Integer]
  # @param language_id [Integer]
  # @return [NameString] a new instance of NameString
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#28
  def initialize(text, platform_id, encoding_id, language_id); end

  # Platform-specific encoding ID.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#18
  def encoding_id; end

  # Language ID.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#22
  def language_id; end

  # Platform ID.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#14
  def platform_id; end

  # Removes chracter incompatible with PostScript.
  #
  # @return [String] PostScript-compatible version of this string.
  #
  # source://ttfunk//lib/ttfunk/table/name.rb#37
  def strip_extended; end
end

# PostScript name for the font ID.
#
# source://ttfunk//lib/ttfunk/table/name.rb#144
TTFunk::Table::Name::POSTSCRIPT_NAME_NAME_ID = T.let(T.unsafe(nil), Integer)

# Typographic Family name ID.
#
# source://ttfunk//lib/ttfunk/table/name.rb#171
TTFunk::Table::Name::PREFERRED_FAMILY_NAME_ID = T.let(T.unsafe(nil), Integer)

# Typographic Subfamily name ID.
#
# source://ttfunk//lib/ttfunk/table/name.rb#174
TTFunk::Table::Name::PREFERRED_SUBFAMILY_NAME_ID = T.let(T.unsafe(nil), Integer)

# Sample text ID.
#
# source://ttfunk//lib/ttfunk/table/name.rb#180
TTFunk::Table::Name::SAMPLE_TEXT_NAME_ID = T.let(T.unsafe(nil), Integer)

# Trademark ID.
#
# source://ttfunk//lib/ttfunk/table/name.rb#147
TTFunk::Table::Name::TRADEMARK_NAME_ID = T.let(T.unsafe(nil), Integer)

# Unique font identifier ID.
#
# source://ttfunk//lib/ttfunk/table/name.rb#134
TTFunk::Table::Name::UNIQUE_SUBFAMILY_NAME_ID = T.let(T.unsafe(nil), Integer)

# Vendor URL ID.
#
# source://ttfunk//lib/ttfunk/table/name.rb#159
TTFunk::Table::Name::VENDOR_URL_NAME_ID = T.let(T.unsafe(nil), Integer)

# Version string ID.
#
# source://ttfunk//lib/ttfunk/table/name.rb#141
TTFunk::Table::Name::VERSION_NAME_ID = T.let(T.unsafe(nil), Integer)

# OS/2 and Windows Metrics (`OS/2`) table
#
# source://ttfunk//lib/ttfunk/table/os2.rb#9
class TTFunk::Table::OS2 < ::TTFunk::Table
  # The typographic ascender for this font.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#100
  def ascent; end

  # Average weighted escapement.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#16
  def ave_char_width; end

  # The Unicode code point, in UTF-16 encoding, of a character that can be
  # used as a default break character.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#141
  def break_char; end

  # The distance between the baseline and the approximate height of
  # uppercase letters.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#130
  def cap_height; end

  # Unicode Character Range.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#80
  def char_range; end

  # Code Page Character Range.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#120
  def code_page_range; end

  # The Unicode code point, in UTF-16 encoding, of a character that can be
  # used for a default glyph if a requested character is not supported in
  # the font.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#136
  def default_char; end

  # The typographic descender for this font.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#104
  def descent; end

  # Font-family class and subclass.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#72
  def family_class; end

  # The minimum Unicode index (character code) in this font.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#92
  def first_char_index; end

  # The maximum Unicode index (character code) in this font.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#96
  def last_char_index; end

  # The typographic line gap for this font.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#108
  def line_gap; end

  # The maximum length of a target glyph context for any feature in this
  # font.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#146
  def max_context; end

  # PANOSE classification number.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#76
  def panose; end

  # Font selection flags.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#88
  def selection; end

  # Table tag.
  #
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#400
  def tag; end

  # Type flags.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#28
  def type; end

  # Font Vendor Identification.
  #
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#84
  def vendor_id; end

  # Table version.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#12
  def version; end

  # Weight class.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#20
  def weight_class; end

  # Width class.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#24
  def width_class; end

  # The "Windows ascender" metric.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#112
  def win_ascent; end

  # The "Windows descender" metric.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#116
  def win_descent; end

  # The distance between the baseline and the approximate height of
  # non-ascending lowercase letters.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#125
  def x_height; end

  # Strikeout position.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#68
  def y_strikeout_position; end

  # Strikeout size.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#64
  def y_strikeout_size; end

  # Subscript x offset.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#40
  def y_subscript_x_offset; end

  # Subscript horizontal font size.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#32
  def y_subscript_x_size; end

  # Subscript y offset.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#44
  def y_subscript_y_offset; end

  # Subscript vertical font size.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#36
  def y_subscript_y_size; end

  # Superscript x offset.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#56
  def y_superscript_x_offset; end

  # Superscript horizontal font size.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#48
  def y_superscript_x_size; end

  # Superscript y offset.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#60
  def y_superscript_y_offset; end

  # Superscript vertical font size.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/os2.rb#52
  def y_superscript_y_size; end

  private

  # source://ttfunk//lib/ttfunk/table/os2.rb#601
  def parse!; end

  class << self
    # Encode table.
    #
    # @param os2 [TTFunk::Table::OS2]
    # @param subset [TTFunk::Subset::MacRoman, TTFunk::Subset::Windows1252, TTFunk::Subset::Unicode, TTFunk::Subset::Unicode8Bit]
    # @return [String]
    #
    # source://ttfunk//lib/ttfunk/table/os2.rb#411
    def encode(os2, subset); end

    private

    # source://ttfunk//lib/ttfunk/table/os2.rb#522
    def avg_char_width_for(os2, subset); end

    # source://ttfunk//lib/ttfunk/table/os2.rb#530
    def avg_ms_symbol_char_width_for(os2, subset); end

    # source://ttfunk//lib/ttfunk/table/os2.rb#548
    def avg_weighted_char_width_for(os2, subset); end

    # source://ttfunk//lib/ttfunk/table/os2.rb#481
    def code_pages_for(subset); end

    # source://ttfunk//lib/ttfunk/table/os2.rb#507
    def group_original_code_points_by_bit(os2); end

    # source://ttfunk//lib/ttfunk/table/os2.rb#489
    def unicode_blocks_for(os2, original_field, subset); end
  end
end

# Space character code point.
#
# source://ttfunk//lib/ttfunk/table/os2.rb#373
TTFunk::Table::OS2::CODEPOINT_SPACE = T.let(T.unsafe(nil), Integer)

# Code page bits.
#
# source://ttfunk//lib/ttfunk/table/os2.rb#149
TTFunk::Table::OS2::CODE_PAGE_BITS = T.let(T.unsafe(nil), Hash)

# Number of chracters for average character width calculation.
#
# source://ttfunk//lib/ttfunk/table/os2.rb#370
TTFunk::Table::OS2::LOWERCASE_COUNT = T.let(T.unsafe(nil), Integer)

# End chracter for average character width calculation.
#
# source://ttfunk//lib/ttfunk/table/os2.rb#367
TTFunk::Table::OS2::LOWERCASE_END = T.let(T.unsafe(nil), Integer)

# Start chracter for average character width calculation.
#
# source://ttfunk//lib/ttfunk/table/os2.rb#364
TTFunk::Table::OS2::LOWERCASE_START = T.let(T.unsafe(nil), Integer)

# Error message for missing space character.
#
# source://ttfunk//lib/ttfunk/table/os2.rb#376
TTFunk::Table::OS2::SPACE_GLYPH_MISSING_ERROR = T.let(T.unsafe(nil), String)

# Unicode blocks.
#
# source://ttfunk//lib/ttfunk/table/os2.rb#185
TTFunk::Table::OS2::UNICODE_BLOCKS = T.let(T.unsafe(nil), Hash)

# Indicates that font supports supplementary characters.
#
# source://ttfunk//lib/ttfunk/table/os2.rb#358
TTFunk::Table::OS2::UNICODE_MAX = T.let(T.unsafe(nil), Integer)

# Unicode block ranges.
#
# source://ttfunk//lib/ttfunk/table/os2.rb#361
TTFunk::Table::OS2::UNICODE_RANGES = T.let(T.unsafe(nil), Array)

# chracter weights for average character width calculation.
#
# source://ttfunk//lib/ttfunk/table/os2.rb#393
TTFunk::Table::OS2::WEIGHT_LOWERCASE = T.let(T.unsafe(nil), Array)

# Used to calculate the xAvgCharWidth field.
# From https://docs.microsoft.com/en-us/typography/opentype/spec/os2:
#
# "When first defined, the specification was biased toward Basic Latin
# characters, and it was thought that the xAvgCharWidth value could be
# used to estimate the average length of lines of text. A formula for
# calculating xAvgCharWidth was provided using frequency-of-use
# weighting factors for lowercase letters a - z."
#
# The array below contains 26 weight values which correspond to the
# 26 letters in the Latin alphabet. Each weight is the relative
# frequency of that letter in the English language.
#
# source://ttfunk//lib/ttfunk/table/os2.rb#390
TTFunk::Table::OS2::WEIGHT_SPACE = T.let(T.unsafe(nil), Integer)

# PostScript (`post`) table.
#
# This class can be extended with version-specific modules.
#
# @see TTFunk::Table::Post::Format10
# @see TTFunk::Table::Post::Format20
# @see TTFunk::Table::Post::Format30
# @see TTFunk::Table::Post::Format40
#
# source://ttfunk//lib/ttfunk/table/post.rb#15
class TTFunk::Table::Post < ::TTFunk::Table
  # 0 if the font is proportionally spaced, non-zero if the font is not
  # proportionally spaced.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/post.rb#35
  def fixed_pitch; end

  # Is this font monospaced?
  #
  # @return [Boolean]
  #
  # source://ttfunk//lib/ttfunk/table/post.rb#75
  def fixed_pitch?; end

  # Table version.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/post.rb#18
  def format; end

  # Get glyph name for character code.
  #
  # This is a placeholder.
  #
  # @param _code [Integer]
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/post.rb#85
  def glyph_for(_code); end

  # Italic angle in counter-clockwise degrees from the vertical.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/post.rb#22
  def italic_angle; end

  # Maximum memory usage when an OpenType font is downloaded as
  # a Type 1 font.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/post.rb#53
  def max_mem_type1; end

  # Maximum memory usage when an OpenType font is downloaded.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/post.rb#43
  def max_mem_type42; end

  # Minimum memory usage when an OpenType font is downloaded as
  # a Type 1 font.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/post.rb#48
  def min_mem_type1; end

  # Minimum memory usage when an OpenType font is downloaded.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/post.rb#39
  def min_mem_type42; end

  # Re-encode this table.
  #
  # @param mapping [Hash{Integer => Integer}] keys are new glyph IDs, values
  #   are old glyph IDs
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/post.rb#94
  def recode(mapping); end

  # Version-specific fields.
  #
  # @return [TTFunk::Table::Post::Format10, TTFunk::Table::Post::Format20, TTFunk::Table::Post::Format30, TTFunk::Table::Post::Format40]
  #
  # source://ttfunk//lib/ttfunk/table/post.rb#58
  def subtable; end

  # Suggested distance of the top of the underline from the baseline
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/post.rb#26
  def underline_position; end

  # Suggested values for the underline thickness.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/post.rb#30
  def underline_thickness; end

  private

  # source://ttfunk//lib/ttfunk/table/post.rb#124
  def parse!; end

  # source://ttfunk//lib/ttfunk/table/post.rb#147
  def parse_format!; end

  class << self
    # Encode table.
    #
    # @param post [TTFunk::Table::Post]
    # @param mapping [Hash{Integer => Integer}] keys are new glyph IDs, values
    #   are old glyph IDs
    # @return [String, nil]
    #
    # source://ttfunk//lib/ttfunk/table/post.rb#66
    def encode(post, mapping); end
  end
end

# Version 1.0 provides glyph names for standard 258 glyphs in the standard
# Macintosh TrueType font file.
#
# source://ttfunk//lib/ttfunk/table/post/format10.rb#8
module TTFunk::Table::Post::Format10
  # Get glyph name for character code.
  #
  # @param code [Integer]
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/post/format10.rb#46
  def glyph_for(code); end

  private

  # source://ttfunk//lib/ttfunk/table/post/format10.rb#52
  def parse_format!; end
end

# Glyph names.
#
# source://ttfunk//lib/ttfunk/table/post/format10.rb#10
TTFunk::Table::Post::Format10::POSTSCRIPT_GLYPHS = T.let(T.unsafe(nil), Array)

# Version 2.0 is used for fonts that use glyph names that are not in the
# set of Macintosh glyph names. A given font may map some of its glyphs to
# the standard Macintosh glyph names, and some to its own custom names.
# A version 2.0 `post` table can be used in fonts with TrueType or CFF
# version 2 outlines.
#
# source://ttfunk//lib/ttfunk/table/post/format20.rb#14
module TTFunk::Table::Post::Format20
  include ::TTFunk::Table::Post::Format10

  # Get glyph name for character code.
  #
  # @param code [Integer]
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/post/format20.rb#21
  def glyph_for(code); end

  private

  # source://ttfunk//lib/ttfunk/table/post/format20.rb#34
  def parse_format!; end
end

# Version 3.0 specifies that no PostScript name information is provided
# for the glyphs in this font file.
#
# source://ttfunk//lib/ttfunk/table/post/format30.rb#8
module TTFunk::Table::Post::Format30
  # Get glyph name for character code.
  #
  # @param _code [Integer]
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/post/format30.rb#13
  def glyph_for(_code); end

  private

  # source://ttfunk//lib/ttfunk/table/post/format30.rb#19
  def parse_format!; end
end

# Version 4.0 names glyphs by their character code.
#
# source://ttfunk//lib/ttfunk/table/post/format40.rb#7
module TTFunk::Table::Post::Format40
  # Get glyph name for character code.
  #
  # @param code [Integer]
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/post/format40.rb#12
  def glyph_for(code); end

  private

  # source://ttfunk//lib/ttfunk/table/post/format40.rb#18
  def parse_format!; end
end

# Standard Bitmap Graphics (`sbix`) table.
#
# source://ttfunk//lib/ttfunk/table/sbix.rb#8
class TTFunk::Table::Sbix < ::TTFunk::Table
  # Get all bitmaps for glyph.
  #
  # @param glyph_id [Integer]
  # @return [Array<BitmapData>]
  #
  # source://ttfunk//lib/ttfunk/table/sbix.rb#72
  def all_bitmap_data_for(glyph_id); end

  # Get bitmap for glyph strike.
  #
  # @param glyph_id [Integer]
  # @param strike_index [Integer]
  # @return [BitmapData]
  #
  # source://ttfunk//lib/ttfunk/table/sbix.rb#49
  def bitmap_data_for(glyph_id, strike_index); end

  # Flags.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/sbix.rb#15
  def flags; end

  # Number of bitmap strikes.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/sbix.rb#19
  def num_strikes; end

  # Strikes.
  #
  # @return [Array<Hash>]
  #
  # source://ttfunk//lib/ttfunk/table/sbix.rb#23
  def strikes; end

  # Table version.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/sbix.rb#11
  def version; end

  private

  # source://ttfunk//lib/ttfunk/table/sbix.rb#80
  def parse!; end
end

# Bitmap Data.
#
# source://ttfunk//lib/ttfunk/table/sbix.rb#42
class TTFunk::Table::Sbix::BitmapData < ::Struct
  # The actual embedded graphic data.
  def data; end

  # The actual embedded graphic data.
  def data=(_); end

  # The PPEM size for which this strike was designed.
  def ppem; end

  # The PPEM size for which this strike was designed.
  def ppem=(_); end

  # The device pixel density (in PPI) for which this strike was designed.
  def resolution; end

  # The device pixel density (in PPI) for which this strike was designed.
  def resolution=(_); end

  # Indicates the format of the embedded graphic data: one of `jpg `,
  # `png `, `tiff`, or the special format `dupe`.
  def type; end

  # Indicates the format of the embedded graphic data: one of `jpg `,
  # `png `, `tiff`, or the special format `dupe`.
  def type=(_); end

  # The horizontal (x-axis) position of the left edge of the bitmap
  # graphic in relation to the glyph design space origin.
  def x; end

  # The horizontal (x-axis) position of the left edge of the bitmap
  # graphic in relation to the glyph design space origin.
  def x=(_); end

  # The vertical (y-axis) position of the bottom edge of the bitmap
  # graphic in relation to the glyph design space origin.
  def y; end

  # The vertical (y-axis) position of the bottom edge of the bitmap
  # graphic in relation to the glyph design space origin.
  def y=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Vertical Origin (`VORG`) table.
#
# source://ttfunk//lib/ttfunk/table/vorg.rb#8
class TTFunk::Table::Vorg < ::TTFunk::Table
  # Number of vertical origin metrics.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/vorg.rb#26
  def count; end

  # The default y coordinate of a glyphs vertical origin.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/vorg.rb#22
  def default_vert_origin_y; end

  # Get vertical origina for glyph by ID.
  #
  # @param glyph_id [Integer]
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/vorg.rb#50
  def for(glyph_id); end

  # Table major version.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/vorg.rb#14
  def major_version; end

  # Table minor version.
  #
  # @return [Integer]
  #
  # source://ttfunk//lib/ttfunk/table/vorg.rb#18
  def minor_version; end

  # Origins map.
  #
  # @return [Hash{Integer => Integer}]
  #
  # source://ttfunk//lib/ttfunk/table/vorg.rb#64
  def origins; end

  # Table tag.
  #
  # @return [String]
  #
  # source://ttfunk//lib/ttfunk/table/vorg.rb#57
  def tag; end

  private

  # source://ttfunk//lib/ttfunk/table/vorg.rb#70
  def parse!; end

  class << self
    # Encode table.
    #
    # @return [String]
    #
    # source://ttfunk//lib/ttfunk/table/vorg.rb#31
    def encode(vorg); end
  end
end

# Table tag.
#
# source://ttfunk//lib/ttfunk/table/vorg.rb#10
TTFunk::Table::Vorg::TAG = T.let(T.unsafe(nil), String)

# Risen when the final encoded string was requested but there were some
# unresolved placeholders in it.
#
# source://ttfunk//lib/ttfunk/encoded_string.rb#9
class TTFunk::UnresolvedPlaceholderError < ::StandardError; end
